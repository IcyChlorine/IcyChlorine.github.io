<!doctype html>
<html lang="zh"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>Linux-0.11 源码解析与思考题 - IcyChlorine&#039;s Blog</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="IcyChlorine&#039;s Blog"><meta name="msapplication-TileImage" content="/img/favicon.svg"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="IcyChlorine&#039;s Blog"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta name="description" content="拟题 杨力祥老师初稿 李效宇同学整理&amp;amp;终稿 李辰剑 2022-12-31 写在前面写作背景这篇笔记来源于这学期的操作系统课程。课程上，杨老师带同学们一起手撕早期版本的 Linux 源代码，非常刺激。 杨老师在期末前出了很多思考题，供同学们参考、复习。李效宇同学则花了不少功夫，结合上课内容和网上资料，整理了所有思考题的答案，分享给同学。   李效宇同学的原文链接：https:&amp;#x2F;&amp;#x2F;lixiex"><meta property="og:type" content="blog"><meta property="og:title" content="Linux-0.11 源码解析与思考题"><meta property="og:url" content="http://icychlorine.github.io/2022/12/31/Linux-0-11-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%E4%B8%8E%E6%80%9D%E8%80%83%E9%A2%98/"><meta property="og:site_name" content="IcyChlorine&#039;s Blog"><meta property="og:description" content="拟题 杨力祥老师初稿 李效宇同学整理&amp;amp;终稿 李辰剑 2022-12-31 写在前面写作背景这篇笔记来源于这学期的操作系统课程。课程上，杨老师带同学们一起手撕早期版本的 Linux 源代码，非常刺激。 杨老师在期末前出了很多思考题，供同学们参考、复习。李效宇同学则花了不少功夫，结合上课内容和网上资料，整理了所有思考题的答案，分享给同学。   李效宇同学的原文链接：https:&amp;#x2F;&amp;#x2F;lixiex"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="http://icychlorine.github.io/2022/12/31/Linux-0-11-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%E4%B8%8E%E6%80%9D%E8%80%83%E9%A2%98/paging.jpeg"><meta property="og:image" content="http://icychlorine.github.io/2022/12/31/Linux-0-11-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%E4%B8%8E%E6%80%9D%E8%80%83%E9%A2%98/pseudo_call.jpeg"><meta property="og:image" content="http://icychlorine.github.io/2022/12/31/Linux-0-11-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%E4%B8%8E%E6%80%9D%E8%80%83%E9%A2%98/trap_init_param.jpeg"><meta property="og:image" content="http://icychlorine.github.io/2022/12/31/Linux-0-11-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%E4%B8%8E%E6%80%9D%E8%80%83%E9%A2%98/seg_descr.jpg"><meta property="og:image" content="http://icychlorine.github.io/2022/12/31/Linux-0-11-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%E4%B8%8E%E6%80%9D%E8%80%83%E9%A2%98/stack_change_on_int.png"><meta property="og:image" content="http://icychlorine.github.io/2022/12/31/Linux-0-11-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%E4%B8%8E%E6%80%9D%E8%80%83%E9%A2%98/linaddr_phyaddr_mapping.png"><meta property="og:image" content="http://icychlorine.github.io/2022/12/31/Linux-0-11-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%E4%B8%8E%E6%80%9D%E8%80%83%E9%A2%98/seg_addressing.png"><meta property="og:image" content="http://icychlorine.github.io/2022/12/31/Linux-0-11-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%E4%B8%8E%E6%80%9D%E8%80%83%E9%A2%98/page_addressing.jpeg"><meta property="og:image" content="http://icychlorine.github.io/2022/12/31/Linux-0-11-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%E4%B8%8E%E6%80%9D%E8%80%83%E9%A2%98/seg_and_paging_addressing.png"><meta property="og:image" content="http://icychlorine.github.io/2022/12/31/Linux-0-11-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%E4%B8%8E%E6%80%9D%E8%80%83%E9%A2%98/wait_list.png"><meta property="og:image" content="http://icychlorine.github.io/2022/12/31/Linux-0-11-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%E4%B8%8E%E6%80%9D%E8%80%83%E9%A2%98/hash_table_a.png"><meta property="og:image" content="http://icychlorine.github.io/2022/12/31/Linux-0-11-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%E4%B8%8E%E6%80%9D%E8%80%83%E9%A2%98/hash_table_b.png"><meta property="article:published_time" content="2022-12-31T12:16:00.000Z"><meta property="article:modified_time" content="2022-12-31T13:37:43.291Z"><meta property="article:author" content="IcyChlorine"><meta property="article:tag" content="操作系统"><meta property="article:tag" content="Linux"><meta property="twitter:card" content="summary"><meta property="twitter:image" content="/2022/12/31/Linux-0-11-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%E4%B8%8E%E6%80%9D%E8%80%83%E9%A2%98/paging.jpeg"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"http://icychlorine.github.io/2022/12/31/Linux-0-11-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%E4%B8%8E%E6%80%9D%E8%80%83%E9%A2%98/"},"headline":"IcyChlorine's Blog","image":["http://icychlorine.github.io/2022/12/31/Linux-0-11-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%E4%B8%8E%E6%80%9D%E8%80%83%E9%A2%98/seg_descr.jpg","http://icychlorine.github.io/2022/12/31/Linux-0-11-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%E4%B8%8E%E6%80%9D%E8%80%83%E9%A2%98/stack_change_on_int.png","http://icychlorine.github.io/2022/12/31/Linux-0-11-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%E4%B8%8E%E6%80%9D%E8%80%83%E9%A2%98/linaddr_phyaddr_mapping.png","http://icychlorine.github.io/2022/12/31/Linux-0-11-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%E4%B8%8E%E6%80%9D%E8%80%83%E9%A2%98/seg_addressing.png","http://icychlorine.github.io/2022/12/31/Linux-0-11-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%E4%B8%8E%E6%80%9D%E8%80%83%E9%A2%98/seg_and_paging_addressing.png","http://icychlorine.github.io/2022/12/31/Linux-0-11-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%E4%B8%8E%E6%80%9D%E8%80%83%E9%A2%98/wait_list.png","http://icychlorine.github.io/2022/12/31/Linux-0-11-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%E4%B8%8E%E6%80%9D%E8%80%83%E9%A2%98/hash_table_a.png","http://icychlorine.github.io/2022/12/31/Linux-0-11-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%E4%B8%8E%E6%80%9D%E8%80%83%E9%A2%98/hash_table_b.png"],"datePublished":"2022-12-31T12:16:00.000Z","dateModified":"2022-12-31T13:37:43.291Z","author":{"@type":"Person","name":"IcyChlorine"},"description":"拟题 杨力祥老师初稿 李效宇同学整理&amp;终稿 李辰剑 2022-12-31 写在前面写作背景这篇笔记来源于这学期的操作系统课程。课程上，杨老师带同学们一起手撕早期版本的 Linux 源代码，非常刺激。 杨老师在期末前出了很多思考题，供同学们参考、复习。李效宇同学则花了不少功夫，结合上课内容和网上资料，整理了所有思考题的答案，分享给同学。   李效宇同学的原文链接：https:&#x2F;&#x2F;lixiex"}</script><link rel="canonical" href="http://icychlorine.github.io/2022/12/31/Linux-0-11-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%E4%B8%8E%E6%80%9D%E8%80%83%E9%A2%98/"><link rel="icon" href="/img/favicon.svg"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.12.0/css/all.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@9.12.0/styles/atom-one-light.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><!--!--><!--!--><script src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" defer></script><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/css/justifiedGallery.min.css"><!--!--><!--!--><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/pace-js@1.0.2/pace.min.js"></script><!--!--><!--!--><meta name="generator" content="Hexo 5.4.0"></head><body class="is-2-column"><nav class="navbar navbar-main"><div class="container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="/img/avatar.webp" alt="IcyChlorine&#039;s Blog" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">Home</a><a class="navbar-item" href="/archives">Archives</a><a class="navbar-item" href="/categories">Categories</a><a class="navbar-item" href="/tags">Tags</a><a class="navbar-item" href="/about">About</a></div><div class="navbar-end"><a class="navbar-item" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/ppoffice/hexo-theme-icarus"><i class="fab fa-github"></i></a><a class="navbar-item search" title="搜索" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-8-widescreen"><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2022-12-31T12:16:00.000Z" title="2022/12/31 20:16:00">2022-12-31</time>发表</span><span class="level-item"><time dateTime="2022-12-31T13:37:43.291Z" title="2022/12/31 21:37:43">2022-12-31</time>更新</span><span class="level-item" id="busuanzi_container_page_pv"><span id="busuanzi_value_page_pv">0</span>次访问</span></div></div><h1 class="title is-3 is-size-4-mobile">Linux-0.11 源码解析与思考题</h1><div class="content"><p>拟题 杨力祥老师<br>初稿 李效宇同学<br>整理&amp;终稿 李辰剑 2022-12-31</p>
<h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><h3 id="写作背景"><a href="#写作背景" class="headerlink" title="写作背景"></a>写作背景</h3><p>这篇笔记来源于这学期的操作系统课程。课程上，杨老师带同学们一起手撕早期版本的 Linux 源代码，非常刺激。</p>
<p>杨老师在期末前出了很多思考题，供同学们参考、复习。李效宇同学则花了不少功夫，结合上课内容和网上资料，整理了所有思考题的答案，分享给同学。</p>
<blockquote>
<p> 李效宇同学的原文链接：<a target="_blank" rel="noopener" href="https://lixiexie.notion.site/dbfc366cee8f4931bfa33d414b1132f9">https://lixiexie.notion.site/dbfc366cee8f4931bfa33d414b1132f9</a></p>
</blockquote>
<p>我看到了这篇长文之后觉得内容很棒，便决定转载到自己的博客上。于是我对内容进行了全面的修订，最终得到了这篇文章。</p>
<h3 id="修订内容"><a href="#修订内容" class="headerlink" title="修订内容"></a>修订内容</h3><p>本以为只是修改一些错别字和优化排版，没有想到最后却成为了大工程，花费了我小半个学期。对文本的修订和优化包括：</p>
<ul>
<li>修订了一些错别字、并对文字进行了润色，让文字更书面化。</li>
<li>对代码使用了程序环境进行排版，优化了总体排版。</li>
<li>修改了一些错误答案，例如“25. 为什么 <code>static inline _syscall0(type,name)</code> 中需要加上关键字 <code>inline</code>？”——实际原因不是优化性能，而是与写时复制 (CoW, Copy on Write) 机制有关。</li>
<li>重写/扩充了一些问题的答案。</li>
<li>对思考题顺序进行了调整，让问题之间的逻辑更紧密连贯。想按寻找某道特定思考题答案的同学，可以参考文末附录：「思考题调整前后编号对照表」。</li>
<li>将许多图片替换为了高清版本，增加了一些示意图。</li>
<li>添加了参考文献。</li>
</ul>
<h3 id="阅读指南"><a href="#阅读指南" class="headerlink" title="阅读指南"></a>阅读指南</h3><p>文中有许多内容是对 Linux-0.11 源代码的解析，还有一部分是对 Intel IA-32 体系结构的分析。对于没有阅读过 Linux 源代码的读者来说可能有些难懂。我建议读者的阅读方法有如下几种：</p>
<ol>
<li><strong>对计算机感兴趣但不熟悉 Linux 源码也不愿意花费太多时间的读者，可以不求甚解地阅读。</strong>文中有一些 IA-32 体系结构相关的内容，也许能拓宽你的知识面，帮助你理解计算机体系结构。文中有一些关于 Linux 操作系统设计思路的内容，也许能向你展现操作系统的具体实现，帮你把抽象的操作系统概念落到具体的实现上。</li>
<li><strong>了解 Linux 源码，或者准备认真研读的读者，可以配合文末给出的参考资料（即参考文献）阅读。</strong>赵炯博士的《Linux内核完全注释》是一本功力极为深厚的 Linux 源码解析专著，我强力推荐。杨力祥老师的《Linux内核设计的艺术》则与文中的思考题思路最为契合。最后，解析 Linux 源码最少不了的便是 Linux 源码本身和 Intel IA-32 芯片手册——后者是当时乃至当今绝大多数操作系统的体系结构基础。源码和《完全注释》可以在 <a target="_blank" rel="noopener" href="http://www.oldlinux.org">www.oldlinux.org</a> 获得，其余资料也大都可以从网上获得。如果你想偷懒，也可以向我发邮件要资料。我的邮箱是 icy_chlorine@pku.edu.cn。</li>
<li><strong>对于正在上/上过杨老师操作系统课的同学，你阅读整篇文章应该没有太大的障碍。</strong>根据杨老师上课的思路或者《Linux内核设计的艺术》书中的思路走即可。</li>
</ol>
<h3 id="记号约定："><a href="#记号约定：" class="headerlink" title="记号约定："></a>记号约定：</h3><ul>
<li><p>寄存器用带百分号的代码环境表示，如 <code>%eip</code>, <code>%eax</code>。</p>
</li>
<li><p>函数、变量、标识符、内存地址用程序环境排版，如 <code>main()</code>, <code>dir</code>, <code>0x7c00</code>。</p>
</li>
<li>体系结构中的专有概念（如全局描述符表 GDT、基本输入输出系统 BIOS）用一般环境排版。</li>
<li>Linus 时代多使用 8 空格长的 tab 缩进，而如今的编辑器大都默认使用 4 个空格缩进，并将 tab 页渲染为四个空格长的空白。为了让代码和注释能正常对齐，将代码中的缩进全部替换为了与当时等长的空格。</li>
<li>引用代码中，用 C++ style 注释（<code>//...</code>）表示我们添加的注解，以和 Linux 源代码中的 C style 注释（<code>/*...*/</code>）区分。</li>
</ul>
<h2 id="Part-I-启动与-Intel-IA-32-体系结构"><a href="#Part-I-启动与-Intel-IA-32-体系结构" class="headerlink" title="Part I 启动与 Intel IA-32 体系结构"></a>Part I 启动与 Intel IA-32 体系结构</h2><h3 id="1-为什么开始启动计算机的时候，执行的是-BIOS-代码而不是操作系统自身的代码？"><a href="#1-为什么开始启动计算机的时候，执行的是-BIOS-代码而不是操作系统自身的代码？" class="headerlink" title="1. 为什么开始启动计算机的时候，执行的是 BIOS 代码而不是操作系统自身的代码？"></a>1. 为什么开始启动计算机的时候，执行的是 BIOS 代码而不是操作系统自身的代码？</h3><p>计算机只能从内存中运行程序，而无法直接从软盘或者硬盘中运行程序。不幸的是，计算机刚启动的时候，内存中空空如也、没有任何程序，需要将程序本身先加载进内存当中。这部分操作就由 BIOS(Basic Input/Output System) 完成。加电后， BIOS 完成一些硬件检测工作，设置实模式下的中断向量表和服务程序，并将操作系统的引导扇区加载至内存地址 <code>0x7C00</code> 处，然后将跳转至 <code>0x7C00</code> 运行操作系统的代码。</p>
<blockquote>
<p>“实模式”是对 Intel x86 体系结构而言的</p>
</blockquote>
<p>BIOS 程序存放在只读存储器 ROM(Read Only Memory) 中。ROM 断电后也能保持信息，但不能改变数据（或修改数据很困难），适合存放 BIOS 这种不需要修改的例行工作。通过内存映射，可以让处理器在上电后最先执行 ROM 中的程序，所以计算机启动最开始运行的是 BIOS 代码。BIOS 在计算机上电启动和操作系统代码之间增加了一层 indirection，使得同样的硬件上可以运行不同的操作系统。</p>
<span id="more"></span>
<h3 id="2-为什么-BIOS-只加载了一个扇区，后续扇区却是由-bootsect-代码加载？为什么-BIOS-没有直接把所有需要加载的扇区都加载？"><a href="#2-为什么-BIOS-只加载了一个扇区，后续扇区却是由-bootsect-代码加载？为什么-BIOS-没有直接把所有需要加载的扇区都加载？" class="headerlink" title="2. 为什么 BIOS 只加载了一个扇区，后续扇区却是由 bootsect 代码加载？为什么 BIOS 没有直接把所有需要加载的扇区都加载？"></a>2. 为什么 BIOS 只加载了一个扇区，后续扇区却是由 <code>bootsect</code> 代码加载？为什么 BIOS 没有直接把所有需要加载的扇区都加载？</h3><blockquote>
<p><code>bootsect</code>, <code>setup</code>, <code>head</code> 指 <code>bootsect.s</code>, <code>setup.s</code>, <code>head.s</code> 编译以后形成的二进制可执行文件。</p>
</blockquote>
<p>BIOS 和操作系统的通常由不同团队开发，按固定的规则约定，可以灵活的设计各自相应的部分。而“BIOS 运行后，只从启动扇区将代码加载至 <code>0x7c00</code> 位置”，便是 BIOS 和操作系统之间相互接洽的约定。以 Linux0.11 为例，后续的扇区由 <code>bootsect</code> 代码加载，这些代码由编写系统的用户负责，与 BIOS 无关。</p>
<p>这样构建的好处是站在整个体系的高度，统一设计和统一安排，简单而有效。BIOS 和操作系统的开发都可以遵循这一约定，灵活地进行各自的设计。例如，BIOS 可以不用知道内核镜像的大小以及其在软盘的分布等等信息，减小了 BIOS 程序的复杂度，降低了硬件上的开销。而操作系统的开发者也可以按照自己的意愿，内存的规划等等都更为灵活。另外，如果要使用 BIOS 进行加载，而且加载完成之后再执行，则需要很长的时间，此外，对于不同的操作系统，其代码长度不一样，可能导致操作系统加载不完全。因此 Linux 采用的是边执行边加载的方法。</p>
<h3 id="3-为什么-BIOS-把-bootsect-加载到-0x07c00，而不是-0x00000？加载后又马上挪到-0x90000-处，是何道理？为什么不一次加载到位？"><a href="#3-为什么-BIOS-把-bootsect-加载到-0x07c00，而不是-0x00000？加载后又马上挪到-0x90000-处，是何道理？为什么不一次加载到位？" class="headerlink" title="3. 为什么 BIOS 把 bootsect 加载到 0x07c00，而不是 0x00000？加载后又马上挪到 0x90000 处，是何道理？为什么不一次加载到位？"></a>3. 为什么 BIOS 把 <code>bootsect</code> 加载到 <code>0x07c00</code>，而不是 <code>0x00000</code>？加载后又马上挪到 <code>0x90000</code> 处，是何道理？为什么不一次加载到位？</h3><blockquote>
<p>若未加说明，十六进制地址默认为内存中地址。</p>
</blockquote>
<ul>
<li><p>加载到 <code>0x07c00</code> 是 BIOS 提前约定设置的。</p>
<ul>
<li>BIOS 把 <code>bootsect.s</code> 加载到 <code>0x07c00</code> 而不是 <code>0x00000</code>，是因为 <code>0x00000</code> 处存放着 BIOS 构建的 1k 大小的中断向量表和 256B 的 BIOS 数据区，这些数据还有用处，不能覆盖。</li>
<li>BIOS把 <code>bootsect.s</code> 加载到 <code>0x07c00</code> 而不是内存高地址处，是因为早期的计算机（IBM兼容机）只有64KB 内存，高地址端为<code>0x7fff</code>。为了把尽量多的连续内存留给操作系统，BIOS 就将读取的数据放到了当时内存地址的尾部。随着计算机的发展，这一约定被保留了下来，于是 BIOS 便一直约定将引导扇区加载到 <code>0x7c00</code> 处[6]。</li>
</ul>
</li>
<li><p>加载后又挪到 <code>0x90000</code>，是因为操作系统规划在内存 <code>0x90000</code> 处存放 <code>bootsect</code>，然后 <code>bootsect</code> 执行结束之后，立即将系统机器数据存放在此处，这样就可以及时回收寿命结束的程序占据的内存空间。而且后续会把120K的系统模块存放到 <code>0x00000</code> 处，这会覆盖 <code>0x07c00</code> 处的代码和数据。 </p>
</li>
<li>不一次加载到位的原因是由于“两头约定”和“定位识别”，所以在开始时 <code>bootsect</code> “被迫”加载到 <code>0x07c00</code> 位置。随后将自身移至 <code>0x90000</code> 处，说明操作系统开始根据自己的需要安排内存了。</li>
</ul>
<h3 id="4-bootsect、setup、head程序之间是怎么衔接的？给出代码证据。"><a href="#4-bootsect、setup、head程序之间是怎么衔接的？给出代码证据。" class="headerlink" title="4. bootsect、setup、head程序之间是怎么衔接的？给出代码证据。"></a>4. <code>bootsect</code>、<code>setup</code>、<code>head</code>程序之间是怎么衔接的？给出代码证据。</h3><ul>
<li><p><code>bootsect</code>→<code>setup</code> 程序：<code>jmpi 0,SETUPSEG</code></p>
<p><code>bootsect</code> 首先利用 <code>int 0x13</code> 中断分别加载 <code>setup</code> 程序及 <code>system</code> 模块，待 <code>bootsect</code> 程序的任务完成之后，执行代码 <code>jmpi 0,SETUPSEG</code>。由于 <code>bootsect</code> 将 <code>setup</code> 段加载到了 <code>SETUPSEG:0</code> （即<code>0x90200</code>），在实模式下，CS:IP 指向 <code>setup</code> 程序的第一条指令，此时 <code>setup</code> 开始执行。</p>
</li>
<li><p><code>setup</code>→<code>head</code> 程序：<code>jmpi 0,8</code></p>
<p>执行 <code>setup</code> 后，内核被移到了 <code>0x00000</code> 处，系统进入了保护模式，执行 <code>jmpi 0,8</code></p>
<p>并加载了中断描述符表和全局描述符表 <code>lidt idt_48; 1gdt gdt_48</code>。在保护模式下，一个重要的特征就是根据 GDT 决定后续执行哪里的程序。该指令执行后跳转到以 GDT 第 2 项中的 <code>base_addr</code> 为基地址，以 0 为偏移量的位置，其中 <code>base_addr</code> 为 <code>0</code>。由于 <code>head</code> 放置在内核的头部，因此程序跳转到 <code>head</code> 中执行。</p>
</li>
</ul>
<h3 id="5-setup-程序的最后是jmpi-0-8-，为什么这个8不能简单的当作阿拉伯数字-8-看待，有什么内涵？"><a href="#5-setup-程序的最后是jmpi-0-8-，为什么这个8不能简单的当作阿拉伯数字-8-看待，有什么内涵？" class="headerlink" title="5. setup 程序的最后是jmpi 0,8 ，为什么这个8不能简单的当作阿拉伯数字 8 看待，有什么内涵？"></a>5. <code>setup</code> 程序的最后是<code>jmpi 0,8</code> ，为什么这个8不能简单的当作阿拉伯数字 8 看待，有什么内涵？</h3><p>此时为 32 位保护模式，<code>0</code> 表示段内偏移，<code>8</code> 表示段选择符。这里8要转化为二进制：<code>1000</code>，最后两位<code>00</code>表示内核特权级（若是 <code>11</code> 则表示用户），第三位 <code>0</code> 表示 GDT 表（若是 <code>1</code> 则表示 LDT 表），第四位 <code>1</code> 表示根据 GDT 中的第2项来确定代码段的段基址和段限长等信息。可以得到代码是从 <code>head</code> 的开始位置，段基址 <code>0x00000000</code>、偏移为 0 处开始执行的，即 <code>head</code> 的开始位置。</p>
<h3 id="6-保护模式在“保护”什么？它的“保护”体现在哪里？特权级的目的和意义是什么？分页有“保护”作用吗？"><a href="#6-保护模式在“保护”什么？它的“保护”体现在哪里？特权级的目的和意义是什么？分页有“保护”作用吗？" class="headerlink" title="6. 保护模式在“保护”什么？它的“保护”体现在哪里？特权级的目的和意义是什么？分页有“保护”作用吗？"></a>6. 保护模式在“保护”什么？它的“保护”体现在哪里？特权级的目的和意义是什么？分页有“保护”作用吗？</h3><ul>
<li><p>保护模式在“保护”什么？它的“保护”体现在哪里？</p>
<p>保护操作系统的安全，不受到恶意攻击。保护进程地址空间相互不干扰。早期的操作系统没有指令集的保护，只是运行在计算机上的一个普通服务程序而已。应用程序甚至可以“干掉”操作系统，释放 OS 占用的内存，来满足自身的需求[7]。</p>
<p>打开保护模式后，CPU 的寻址模式发生了变化，基于全局描述符表 GDT 去获取代码或数据段的基址限长，不同段不能被随意访问。这防止了对代码或数据段的覆盖以及代码段自身的访问超限，明显增强了保护作用。保护模式下的处理器对描述符所描述的对象进行保护：在 GDT、 LDT 及 IDT 中，均有对应界限、特权级等概念，这是对描述符所描述的对象的保护。在不同特权级间访问时，系统会对 CPL、 RPL、 DPL、 IOPL 等进行检验，特权级不够的代码无法访问高权限的段。同时，处理器页会限制某些特殊指令如 <code>lgdt</code>, <code>lidt</code>, <code>cli</code> 等的使用；分页机制中， PDE 和 PTE 中的 <code>R/W</code> 和 <code>U/S</code> 等位提供了页级保护，分页机制通过将线性地址与物理地址的映射，提供了对物理地址的保护。</p>
</li>
<li><p>特权级的目的和意义是什么？</p>
<p><strong>特权级机制目的是</strong>为了进行合理的管理资源，保护高特权级的段。其中操作系统的内核处于最高的特权级。</p>
<p>特权级机制对系统进行了保护，对操作系统的“主奴机制”影响深远。Intel 从硬件上禁止低特权级代码段使用部分关键性指令，例如禁止用户进程使用 <code>cli</code>、 <code>sti</code> 等对掌控局面至关重要的指令。这使得操作系统有可能真正成为计算机上超越用户进程的存在，而不仅仅是一个服务性程序。有了这些基础，操作系统可以把内核设计成最高特权级，把用户进程设计成最低特权级。这样，操作系统可以访问 GDT、 LDT、 TR，而 GDT、 LDT 是逻辑地址变换至线性地址的关键，因此操作系统可以掌控线性地址。物理地址是由内核将线性地址转换而成的，所以操作系统可以访问任何物理地址，而用户进程只能使用逻辑地址。总之，特权级的引入对操作系统内核进行保护。</p>
</li>
<li><p>「分页」有“保护”作用吗？</p>
<p><strong>分页机制有保护作用</strong>，使得用户进程不能直接访问内核地址，进程间也不能相互访问。用户进程只能使用逻辑地址，而逻辑地址通过内核转化为线性地址，根据内核提供的专门为进程设计的分页方案，由 MMU 直接映射转化为实际物理地址形成保护。此外，通过分页机制，每个进程都有自己的专属页表，有利于更安全、高效的使用内存，保护每个进程的地址空间。</p>
<p>事实上，在较新版本的 Linux 中，内存保护已经改由分页机制实现，不再使用段机制实现了。这是因为分页的控制更扁平化，更灵活，且在不同体系结构上的可移植性更好。</p>
</li>
<li><p>为什么特权级是基于段的？</p>
<p>在操作系统设计中，一个段一般实现的功能相对完整，可以把代码放在一个段，数据放在一个段，并通过段选择符（包括 <code>CS</code>、<code>SS</code>、<code>DS</code>、<code>ES</code>、<code>FS</code> 和 <code>GS</code> 寄存器）获取段的基址和特权级等信息。通过段，系统划分了内核代码段、内核数据段、用户代码段和用户数据段等不同的数据段，有些段是系统专享的，有些是和用户程序共享的，因此就有特权级的概念。特权级基于段，这样当段选择子具有不匹配的特权级时，按照特权级规则评判是否可以访问。特权级基于段，是结合了程序的特点和硬件实现的一种考虑。</p>
</li>
</ul>
<h3 id="7-打开-A20-和打开-PE-究竟是什么关系，保护模式不就是-32-位的吗？为什么还要打开-A20？有必要吗？"><a href="#7-打开-A20-和打开-PE-究竟是什么关系，保护模式不就是-32-位的吗？为什么还要打开-A20？有必要吗？" class="headerlink" title="7. 打开 A20 和打开 PE 究竟是什么关系，保护模式不就是 32 位的吗？为什么还要打开 A20？有必要吗？"></a>7. <strong>打开 A20 和打开 PE 究竟是什么关系，保护模式不就是 32 位的吗？为什么还要打开 A20？有必要吗？</strong></h3><p>PE(Protection Enabled) 是 <code>%eflags</code> 中的重要一位，用于设置保护模式，在置位时开启。而 A20(Address 20) 是另一个控制位，用于让 x86 芯片接受高于 20 位的地址，而不是进行地址环绕。二者都是 x86 系列芯片为了兼容性而设计，但却<strong>相互独立</strong>，打开一者并不意味着打开另一者。</p>
<p>打开 A20 仅仅意味着 CPU 可以进行 32 位寻址，且最大寻址空间是 4GB。打开 PE 是进入保护模式，从而可能进行安全的系统编程，此时物理地址和线性地址一 一对应。A20 会控制 CPU 的第 21 位~第 32 位地址线，A20 未打开的时候，第 21 根及以上地址线被强制置为为 0，所以相当于 CPU “回滚”到内存地址起始处寻址。这是为了完全兼容以前在「只有 20 位寻址空间的 CPU 」上写的程序所设计的。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>寻址情况</th>
<th>不打开 A20（上电默认状态）</th>
<th>打开 A20</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>实模式</strong></td>
<td><code>cs:ip</code> 最大寻址为 <code>(0xFFFFF:0xFFFFF)%0x100000=0xFFEF</code></td>
<td>可以寻址到 1MB 以上的高地址内存区</td>
</tr>
<tr>
<td><strong>保护模式</strong></td>
<td>只能访问奇数 1M 段，即 0-1M，2M-3M，4-5M 等</td>
<td>可以访问的内存是连续的</td>
</tr>
</tbody>
</table>
</div>
<p>打开 A20 是打开 PE 的必要条件；而打开 A20 不一定非得打开 PE。显然，A20 和 PE 必须分别打开，否则保护模式将无法正常工作。</p>
<h3 id="8-在-setup-程序里曾经设置过-GDT，为什么在-head-程序中又将其废弃，重新设置了一个？为什么设置两次，而不是一次搞好？"><a href="#8-在-setup-程序里曾经设置过-GDT，为什么在-head-程序中又将其废弃，重新设置了一个？为什么设置两次，而不是一次搞好？" class="headerlink" title="8. 在 setup 程序里曾经设置过 GDT，为什么在 head 程序中又将其废弃，重新设置了一个？为什么设置两次，而不是一次搞好？"></a>8. 在 <code>setup</code> 程序里曾经设置过 GDT，为什么在 <code>head</code> 程序中又将其废弃，重新设置了一个？为什么设置两次，而不是一次搞好？</h3><p>第一次设置 GDT 所在的位置是在 <code>setup.s</code> 中，然而将来 <code>setup</code> 所在的内存位置会被缓冲区<strong>覆盖</strong>，如果不改变位置，GDT 的内容将被缓冲区覆盖掉，从而影响系统的运行。这样一来，将来整个内存中唯一安全的地方就是现在 <code>head.s</code> 所在的位置了。</p>
<p>那么有没有可能在执行 <code>setup</code> 程序时直接把 GDT 的内容<strong>复制</strong>到 <code>head.s</code> 所在的位置呢？答案是否定的。如果先复制 GDT 的内容、后移动 <code>system</code> 模块，GDT 会被后者覆盖；如果先移动 <code>system</code> 模块，后复制 GDT 的内容，它又会把 <code>head.s</code> 对应的程序覆盖，而这时 <code>head</code> 还没有执行。所以，无论如何，都要重新建立 GDT。</p>
<blockquote>
<p><code>system</code> 模块是指内核在内存中的映像。</p>
</blockquote>
<h3 id="9-用户进程自己设计一套-LDT-表，并与-GDT-挂接，是否可行，为什么？"><a href="#9-用户进程自己设计一套-LDT-表，并与-GDT-挂接，是否可行，为什么？" class="headerlink" title="9. 用户进程自己设计一套 LDT 表，并与 GDT 挂接，是否可行，为什么？"></a>9. <strong>用户进程自己设计一套 LDT 表，并与 GDT 挂接，是否可行，为什么？</strong></h3><p><strong>不可行。</strong></p>
<p>首先，用户进程不可以设置 GDT、LDT，因为 Linux-0.11 将 GDT、LDT 这两个数据结构设置在内核数据区，是 0 特权级的，只有 0 特权级的代码才能修改设置 GDT、LDT。<strong>因此，用户进程不能直接修改已存在的 GDT、LDT。</strong></p>
<p><strong>而且，用户也不可以在自己的数据段按照自己的意愿重新做一套 GDT、LDT。</strong>如果仅仅是形式上做一套和GDT、LDT一样的数据结构是可以的，但是真正起作用的 GDT、LDT 是 CPU 硬件认定的，这两个数据结构的首地址必须挂载在 CPU 的 <code>%GDTR</code>、<code>%LDTR</code> 寄存器上，运行时 CPU 只认 <code>%GDTR</code> 和 <code>%LDTR</code> 指向的数据结构，其他数据结构就算起名字叫 GDT、LDT，CPU 也一概不认；另外，用户进程也不能将自己制作的 GDT、LDT 挂接到 GDRT、LDRT 上，因为对 <code>%GDTR</code> 和 <code>%LDTR</code> 的设置（<code>lgdt</code>等指令）只能在 0 特权级别下执行，3 特权级别下无法把这套结构挂接到 <code>%GDTR</code> 和 <code>%LDTR</code> 上。</p>
<h3 id="10-setup-s-程序里的-cli-是为了什么？"><a href="#10-setup-s-程序里的-cli-是为了什么？" class="headerlink" title="10. setup.s 程序里的 cli 是为了什么？"></a>10. <code>setup.s</code> 程序里的 <code>cli</code> 是为了什么？</h3><p><code>cli</code> 是关中断指令，意味着程序在接下来的执行过程中，系统不会对中断进行响应。原因很简单：在 <code>setup</code> 程序中，操作系统将要重新设置中断向量表和中断服务程序，在这个过程中是无法进行正常中断的。因此，操作系统先将中断关闭，直到中断重新设置完成后再打开中断，即运行 <code>sti</code> 指令。</p>
<p>在 <code>setup</code> 中，需要将位于 <code>0x10000</code> 的内核程序复制到 <code>0x00000</code> 处，BIOS 创建的原生中断向量表覆盖掉了。若此时产生中断，将产生不可预知的错误，所以要禁止中断。此外，此时也是由 16 位实模式向 32 位保护模式转变的时候，需要在保护模式下重新建立中断描述符表的交接工作，正是实模式的中断机制向保护模式的中断机制交接的时候。在保护模式的中断机制尚未完成时不允许响应中断，以免发生未知的错误。</p>
<h3 id="11-进程-0-的-task-struct-在哪？具体内容是什么？"><a href="#11-进程-0-的-task-struct-在哪？具体内容是什么？" class="headerlink" title="11. 进程 0 的 task_struct 在哪？具体内容是什么？"></a>11. 进程 0 的 <code>task_struct</code> 在哪？具体内容是什么？</h3><p>进程 0 的 <code>task_struct</code> 位于内核数据区，因为在进程 0 未激活之前，使用的是 boot 阶段的 <code>user_stack</code>，因此存储在 <code>user_stack</code> 中。 具体内容：包含了进程 0 的进程状态、进程 0 的 LDT、进程 0 的 TSS 等等。其中 LDT 设置了代码段和堆栈段的基址和限长(640KB)，而 TSS 则保存了各种寄存器的值，包括各个段选择符。</p>
<p>代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 代码路径：include/linux/sched.h</span></span><br><span class="line"><span class="comment">// 赋给进程0的task_struct值</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *  INIT_TASK is used to set up the first task table, touch at</span></span><br><span class="line"><span class="comment"> * your own risk!. Base=0, limit=0x9ffff (=640kB)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INIT_TASK \\</span></span><br><span class="line"><span class="comment">/* state etc */</span> &#123; <span class="number">0</span>,<span class="number">15</span>,<span class="number">15</span>, \\</span><br><span class="line"><span class="comment">/* signals */</span>   <span class="number">0</span>,&#123;&#123;&#125;,&#125;,<span class="number">0</span>, \\</span><br><span class="line"><span class="comment">/* ec,brk... */</span> <span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>, \\</span><br><span class="line"><span class="comment">/* pid etc.. */</span> <span class="number">0</span>,<span class="number">-1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>, \\</span><br><span class="line"><span class="comment">/* uid etc */</span>   <span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>, \\</span><br><span class="line"><span class="comment">/* alarm */</span>     <span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>, \\</span><br><span class="line"><span class="comment">/* math */</span>      <span class="number">0</span>, \\</span><br><span class="line"><span class="comment">/* fs info */</span>   <span class="number">-1</span>,<span class="number">0022</span>,<span class="literal">NULL</span>,<span class="literal">NULL</span>,<span class="literal">NULL</span>,<span class="number">0</span>, \\</span><br><span class="line"><span class="comment">/* filp */</span>      &#123;<span class="literal">NULL</span>,&#125;, \\</span><br><span class="line">        &#123; \\</span><br><span class="line">                &#123;<span class="number">0</span>,<span class="number">0</span>&#125;, \\</span><br><span class="line"><span class="comment">/* ldt */</span>       &#123;<span class="number">0x9f</span>,<span class="number">0xc0fa00</span>&#125;, \\</span><br><span class="line">                &#123;<span class="number">0x9f</span>,<span class="number">0xc0f200</span>&#125;, \\</span><br><span class="line">        &#125;, \\</span><br><span class="line"><span class="comment">/*tss*/</span> &#123;<span class="number">0</span>,PAGE_SIZE+(<span class="keyword">long</span>)&amp;init_task,<span class="number">0x10</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,(<span class="keyword">long</span>)&amp;pg_dir,\\</span><br><span class="line">        <span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>, \\</span><br><span class="line">        <span class="number">0</span>,<span class="number">0</span>,<span class="number">0x17</span>,<span class="number">0x17</span>,<span class="number">0x17</span>,<span class="number">0x17</span>,<span class="number">0x17</span>,<span class="number">0x17</span>, \\</span><br><span class="line">        _LDT(<span class="number">0</span>),<span class="number">0x80000000</span>, \\</span><br><span class="line">                &#123;&#125; \\</span><br><span class="line">        &#125;, \\</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="12-内核的线性地址空间是如何分页的？画出从-0x000000-开始的7个页（包括页目录表、页表所在页）的挂接关系图。页目录表的前四个页目录项、第一个页表的前7个页表项指向什么位置？给出代码证据。"><a href="#12-内核的线性地址空间是如何分页的？画出从-0x000000-开始的7个页（包括页目录表、页表所在页）的挂接关系图。页目录表的前四个页目录项、第一个页表的前7个页表项指向什么位置？给出代码证据。" class="headerlink" title="12. 内核的线性地址空间是如何分页的？画出从 0x000000 开始的7个页（包括页目录表、页表所在页）的挂接关系图。页目录表的前四个页目录项、第一个页表的前7个页表项指向什么位置？给出代码证据。"></a>12. 内核的线性地址空间是如何分页的？画出从 <code>0x000000</code> 开始的7个页（包括页目录表、页表所在页）的挂接关系图。页目录表的前四个页目录项、第一个页表的前7个页表项指向什么位置？给出代码证据。</h3><p><strong>如何分页：</strong><code>head.s</code> 在 <code>setup_paging</code> 开始创建分页机制。将页目录表和4个页表放到物理内存的起始位置，从内存起始位置开始的5个页空间内容全部清零（每页4KB），然后设置页目录表的前4项，使之分别指向4个页表。然后开始从高地址向低地址方向填写4个页表，依次指向内存从高地址向低地址方向的各个页面。即将第4个页表的最后一项指向寻址范围的最后一个页面。即从 <code>0xfff000</code> 开始的 4KB 大小的内存空间。将第4个页表的倒数第二个页表项指向倒数第二个页面，即 <code>0xfff000-0x1000000</code> 开始的4KB字节的内存空间，依此类推。</p>
<p>挂接关系图：</p>
<div align="center">
<img src="/2022/12/31/Linux-0-11-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%E4%B8%8E%E6%80%9D%E8%80%83%E9%A2%98/paging.jpeg" alt="内核的页目录表和页表[2]"><br>
</div>

<p>代码证据：</p>
<blockquote>
<p>注意，页目录表需指向所有页表；页表须要指向所有页；页目录表、页表自己也是页。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 代码路径：boot&#x2F;head.s</span><br><span class="line">.align 2</span><br><span class="line">setup_paging:</span><br><span class="line">        movl $1024*5,%ecx               &#x2F;* 5 pages - pg_dir+4 page tables *&#x2F;</span><br><span class="line">        xorl %eax,%eax</span><br><span class="line">        xorl %edi,%edi                  &#x2F;* pg_dir is at 0x000 *&#x2F;</span><br><span class="line">        cld;rep;stosl</span><br><span class="line">        movl $pg0+7,_pg_dir             &#x2F;* set present bit&#x2F;user r&#x2F;w *&#x2F;</span><br><span class="line">        movl $pg1+7,_pg_dir+4           &#x2F;*  --------- &quot; &quot; --------- *&#x2F;</span><br><span class="line">        movl $pg2+7,_pg_dir+8           &#x2F;*  --------- &quot; &quot; --------- *&#x2F;</span><br><span class="line">        movl $pg3+7,_pg_dir+12          &#x2F;*  --------- &quot; &quot; --------- *&#x2F;</span><br><span class="line">        movl $pg3+4092,%edi</span><br><span class="line">        movl $0xfff007,%eax             &#x2F;*  16Mb - 4096 + 7 (r&#x2F;w user,p) *&#x2F;</span><br><span class="line">        std</span><br><span class="line">1:      stosl                   &#x2F;* fill pages backwards - more efficient :-) *&#x2F;</span><br><span class="line">        subl $0x1000,%eax</span><br><span class="line">        jge 1b</span><br><span class="line">        xorl %eax,%eax          &#x2F;* pg_dir is at 0x0000 *&#x2F;</span><br><span class="line">        movl %eax,%cr3          &#x2F;* cr3 - page directory start *&#x2F;</span><br><span class="line">        movl %cr0,%eax</span><br><span class="line">        orl $0x80000000,%eax</span><br><span class="line">        movl %eax,%cr0          &#x2F;* set paging (PG) bit *&#x2F;</span><br><span class="line">        ret                     &#x2F;* this also flushes prefetch-queue *&#x2F;</span><br></pre></td></tr></table></figure>
<h3 id="13-在-head-程序执行结束的时候，在-IDT-的前面有-184-个字节的-head-程序的剩余代码，剩余了什么？为什么要剩余？"><a href="#13-在-head-程序执行结束的时候，在-IDT-的前面有-184-个字节的-head-程序的剩余代码，剩余了什么？为什么要剩余？" class="headerlink" title="13. 在 head 程序执行结束的时候，在 IDT 的前面有 184 个字节的 head 程序的剩余代码，剩余了什么？为什么要剩余？"></a>13. 在 <code>head</code> 程序执行结束的时候，在 IDT 的前面有 184 个字节的 <code>head</code> 程序的剩余代码，剩余了什么？为什么要剩余？</h3><p>在 IDT 前面有 184 个字节的剩余代码，剩余内容在 <code>0x054b8</code>~<code>0x05400</code>处，包含了 <code>after_page_tables</code>、<code>ignore_int</code> 中断服务程序和 <code>setup_paging</code> 设置分页的代码。其中 <code>after_page_tables</code> 往栈中压入了些参数，<code>ignore_int</code> 用做初始化中断时的中断处理函数，<code>setup_paging</code>则用于初始化分页。</p>
<p><strong>剩余的原因：</strong><code>after_page_tables</code> 中压入了一些参数，为内核进入 <code>main()</code> 函数跳转做准备，为了谨慎起见，设计者在栈中压入了 <code>L6</code>，以使得系统可能出错时，返回 <code>L6</code> 处执行。这部分代码可能返回，因此要放在页表后面。</p>
<p><code>ignore_int</code>为中断处理函数，因此如果中断开启后，可能使用了未设置的中断向量，那么将默认跳转到<code>ignore_int</code> 处执行。因此不能被覆盖。</p>
<p><code>setup_paging</code> 部分用于设置页表，在分页完成前不能被覆盖，因此放在页表的后面。</p>
<h3 id="14-为什么不用-call，而是用-ret-“调用”-main-函数？画出调用路线图，给出代码证据。"><a href="#14-为什么不用-call，而是用-ret-“调用”-main-函数？画出调用路线图，给出代码证据。" class="headerlink" title="14. 为什么不用 call，而是用 ret “调用” main 函数？画出调用路线图，给出代码证据。"></a>14. 为什么不用 <code>call</code>，而是用 <code>ret</code> “调用” <code>main</code> 函数？画出调用路线图，给出代码证据。</h3><p><code>call</code> 指令会将 <code>%eip</code> 的值自动压栈，保护返回现场，然后执行被调函数的程序，等到执行被调函数的 <code>ret</code> 指令时，自动出栈给 <code>%eip</code> 并还原现场，继续执行原来 <code>call</code> 后的下一条指令。然而对操作系统的 <code>main()</code> 来说，如果由 <code>call</code> 调用 <code>main()</code> 函数，那么函数最后返回给谁呢？在由 <code>head</code> 程序向 <code>main</code> 函数跳转时，是不需要 <code>main</code> 函数返回的；从逻辑上来说，<code>main</code> 作为任何 C 程序的主入口，也不应该返回到其它位置的——它本身就是最“基本”的函数。因此代码中没有使用 <code>call</code> 调用 <code>main</code>，而是手动压栈（模仿了 <code>call</code> 的全部动作），并“返回”至 <code>main</code> 函数。</p>
<p>具体来说，操作系统先通过手动压栈调用 <code>setup_paging</code> 函数，压栈的 <code>%eip</code> 值不是调用 <code>setup_paging</code> 函数的下一行指令的地址，而是 <code>main()</code> 的入口地址。当 <code>setup_paging</code> 函数执行到 <code>ret</code> 时，从栈中将 <code>main()</code> 的入口地址 <code>_main</code> 自动出栈给 <code>%eip</code>，<code>%eip</code> 指向 <code>main</code> 函数的入口地址，便实现了用返回指令调用 <code>main</code> 函数。这样以来，就通过 <code>ret</code> ——而不是 <code>call</code> 指令——将逻辑控制流转交给了 <code>main</code> 函数，在方法论上确保了 <code>main</code> 在整个操作系统中的核心地位。</p>
<div align="center">
<img src="/2022/12/31/Linux-0-11-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%E4%B8%8E%E6%80%9D%E8%80%83%E9%A2%98/pseudo_call.jpeg" alt="仿call示意图[2]"><br>
</div>

<p>代码参考：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># 代码路径：boot&#x2F;head.s</span><br><span class="line">after_page_tables:</span><br><span class="line">        pushl $0                # These are the parameters to main :-)</span><br><span class="line">        pushl $0</span><br><span class="line">        pushl $0</span><br><span class="line">        pushl $L6               # return address for main, if it decides to.</span><br><span class="line">        pushl $_main</span><br><span class="line">        jmp setup_paging</span><br><span class="line">L6:</span><br><span class="line">        jmp L6                  # main should never return here, but</span><br><span class="line">                                # just in case, we know what happens.</span><br></pre></td></tr></table></figure>
<h3 id="15-Linux-是用-C-语言写的，为什么没有从-main-开始，而是先运行3-个汇编程序，道理何在？"><a href="#15-Linux-是用-C-语言写的，为什么没有从-main-开始，而是先运行3-个汇编程序，道理何在？" class="headerlink" title="15. Linux 是用 C 语言写的，为什么没有从 main 开始，而是先运行3 个汇编程序，道理何在？"></a>15. <strong>Linux 是用 C 语言写的，为什么没有从 <code>main</code> 开始，而是先运行3 个汇编程序，道理何在？</strong></h3><p>通常用 C 语言编写的程序都是<strong>用户应用程序</strong>，这类程序的执行必须在操作系统上执行，也就是说要由操作系统为应用程序创建进程，并把应用程序的可执行代码从硬盘加载到内存。</p>
<p>然而，对于操作系统而言，在 BIOS 之后就要开始运行。但 CPU 启动时默认为16位的实模式（BIOS加载完之后仍然在实模式），开机时的 16 位实模式与 main 函数执行需要的 32 位保护模式之间有很大的差距。此时内存中没有操作系统程序，只有 BIOS 程序。操作系统需要借助 BIOS 分别加载 <code>bootsect</code> 、<code>setup</code> 及 <code>system</code> 模块，然后利用这 3 个程序来完成内存规划、建立 IDT 和 GDT、设置分页机制等等。其中 <code>bootsect</code> 负责加载，<code>setup</code> 与 <code>head</code> 则负责获取硬件参数，准备 IDT、GDT，开启 A20, PE, PG, 废弃旧的 16 位中断响应机制，建立新的 32 为 IDT，设置分页机制等，实现从开机时的 16 位实模式到 <code>main</code> 函数执行需要的 32 位保护模式之间的转换。当计算机处在 32 位的保护模式状态下时，调用 <code>main</code> 的条件才算准备完毕。</p>
<p>由此可见，在真正能调用一个 C 程序之前，还有大量的更为基本的准备工作要做，而这些准备工作往往需要更为底层的汇编语言来完成。<strong>因此，启动时需要先调用少量汇编程序，做好体系结构层级的基本准备之后再转入 C 语言编写的程序。</strong></p>
<h3 id="16-用文字和图说明一个中断描述符表是如何初始化的，可以举例说明（比如：set-trap-gate-0-amp-divide-error-），并给出代码证据。"><a href="#16-用文字和图说明一个中断描述符表是如何初始化的，可以举例说明（比如：set-trap-gate-0-amp-divide-error-），并给出代码证据。" class="headerlink" title="16. 用文字和图说明一个中断描述符表是如何初始化的，可以举例说明（比如：set_trap_gate(0,&amp;divide_error)），并给出代码证据。"></a>16. 用文字和图说明一个中断描述符表是如何初始化的，可以举例说明（比如：<code>set_trap_gate(0,&amp;divide_error)</code>），并给出代码证据。</h3><p>对中断描述符表的初始化，就是将中断、异常处理的服务程序与 IDT 进行挂接，逐步重建中断服务体系。</p>
<p>以 <code>set_trap_gate(0,&amp;divide_error)</code> 为例，函数的原型为：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 代码路径：include/asm/system.h</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> set_trap_gate(n,addr) \\</span></span><br><span class="line">        _set_gate(&amp;idt[n],<span class="number">15</span>,<span class="number">0</span>,addr)</span><br></pre></td></tr></table></figure>
<p>这是一个宏函数，展开到一般的门设置函数 <code>_set_gate</code>。其中，<code>n</code> 是 <code>0</code>，最终会指向 <code>&amp;idt[0]</code>，也就是 IDT 第一项中断描述符的地址；<code>type</code> 是 <code>15</code>（32位门，陷进门），<code>dpl</code>（描述符特权级）是 <code>0</code>；<code>addr</code> 是中断服务程序 <code>divide_error(void)</code> 的入口地址。</p>
<div align="center">
<img src="/2022/12/31/Linux-0-11-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%E4%B8%8E%E6%80%9D%E8%80%83%E9%A2%98/trap_init_param.jpeg" alt="参数对应示意图[2]"><br>
</div>

<p>最终真正进行 IDT 设置的代码是一段内嵌汇编代码，见下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 代码路径：include/asm/system.h</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _set_gate(gate_addr,type,dpl,addr) \\</span></span><br><span class="line">__asm__ (<span class="string">&quot;movw %%dx,%%ax\\n\\t&quot;</span> \\</span><br><span class="line">        <span class="string">&quot;movw %0,%%dx\\n\\t&quot;</span> \\</span><br><span class="line">        <span class="string">&quot;movl %%eax,%1\\n\\t&quot;</span> \\</span><br><span class="line">        <span class="string">&quot;movl %%edx,%2&quot;</span> \\</span><br><span class="line">        : \\</span><br><span class="line">        : <span class="string">&quot;i&quot;</span> ((<span class="keyword">short</span>) (<span class="number">0x8000</span>+(dpl&lt;&lt;<span class="number">13</span>)+(type&lt;&lt;<span class="number">8</span>))), \\</span><br><span class="line">        <span class="string">&quot;o&quot;</span> (*((<span class="keyword">char</span> *) (gate_addr))), \\</span><br><span class="line">        <span class="string">&quot;o&quot;</span> (*(<span class="number">4</span>+(<span class="keyword">char</span> *) (gate_addr))), \\</span><br><span class="line">        <span class="string">&quot;d&quot;</span> ((<span class="keyword">char</span> *) (addr)),<span class="string">&quot;a&quot;</span> (<span class="number">0x00080000</span>))</span><br></pre></td></tr></table></figure>
<p>刚开始中断服务程序地址 <code>&amp;divide_error</code> 存储在 <code>%edx</code> 中，段选择子 <code>0008</code> 存储在 <code>%eax</code> 的高字，将 <code>%edx</code> 低字赋给 <code>%eax</code> 的低字组成中断描述符表的低 32 位，<code>0x8000+ (dpl&lt;&lt;13) + (type&lt;&lt;8)</code> 即二进制<code>1000111100000000</code>是对 <code>p</code> 位、<code>type</code> 位、<code>dpl</code> 位的设置，然后赋给 <code>%edx</code> 的低位组成中断描述符表的高32位，最后将 <code>%edx</code>、<code>%eax</code> 分别写入中断描述符表的高32位和低32位。</p>
<h3 id="17-分析初始化IDT、GDT、LDT的代码。"><a href="#17-分析初始化IDT、GDT、LDT的代码。" class="headerlink" title="17. 分析初始化IDT、GDT、LDT的代码。"></a>17. <strong>分析初始化IDT、GDT、LDT的代码。</strong></h3><p>IDT:</p>
<ul>
<li><p>初始化各种异常处理服务程序的中断描述符，例如除零错误(<code>divide_error</code>)、保护错误(<code>general_protection</code>)、页故障(<code>page_fault</code>)等等。</p>
</li>
<li><p>将剩余的中断处理程序都都初始化为默认项，即将 <code>int 0x11~0x2F</code> 的中断服务程序的指针设置为 <code>reserved</code>。</p>
</li>
<li><p>设置协处理器 x387 的 IDT 项。</p>
</li>
<li><p>允许主8259A中断控制器的 IRQ2、IRQ13 的中断请求。</p>
</li>
<li><p>设置并口（可连接接打印机）的 IDT 项。</p>
<p>代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 代码路径：kernel/traps.c</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">trap_init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line">        set_trap_gate(<span class="number">0</span>,&amp;divide_error); <span class="comment">// 设置各类处理器异常的处理程序</span></span><br><span class="line">        set_trap_gate(<span class="number">1</span>,&amp;debug);</span><br><span class="line">        set_trap_gate(<span class="number">2</span>,&amp;nmi);</span><br><span class="line">        set_system_gate(<span class="number">3</span>,&amp;int3);	<span class="comment">/* int3-5 can be called from all */</span></span><br><span class="line">        set_system_gate(<span class="number">4</span>,&amp;overflow);</span><br><span class="line">        set_system_gate(<span class="number">5</span>,&amp;bounds);</span><br><span class="line">        set_trap_gate(<span class="number">6</span>,&amp;invalid_op);</span><br><span class="line">        set_trap_gate(<span class="number">7</span>,&amp;device_not_available);</span><br><span class="line">        set_trap_gate(<span class="number">8</span>,&amp;double_fault);</span><br><span class="line">        set_trap_gate(<span class="number">9</span>,&amp;coprocessor_segment_overrun);</span><br><span class="line">        set_trap_gate(<span class="number">10</span>,&amp;invalid_TSS);</span><br><span class="line">        set_trap_gate(<span class="number">11</span>,&amp;segment_not_present);</span><br><span class="line">        set_trap_gate(<span class="number">12</span>,&amp;stack_segment);</span><br><span class="line">        set_trap_gate(<span class="number">13</span>,&amp;general_protection);</span><br><span class="line">        set_trap_gate(<span class="number">14</span>,&amp;page_fault);</span><br><span class="line">        set_trap_gate(<span class="number">15</span>,&amp;reserved);</span><br><span class="line">        set_trap_gate(<span class="number">16</span>,&amp;coprocessor_error); <span class="comment">// 协处理器中断</span></span><br><span class="line">        <span class="keyword">for</span> (i=<span class="number">17</span>;i&lt;<span class="number">48</span>;i++)</span><br><span class="line">                set_trap_gate(i,&amp;reserved);</span><br><span class="line">        set_trap_gate(<span class="number">45</span>,&amp;irq13);</span><br><span class="line">        outb_p(inb_p(<span class="number">0x21</span>)&amp;<span class="number">0xfb</span>,<span class="number">0x21</span>); <span class="comment">// 允许主8259A芯片的IRQ2中断请求</span></span><br><span class="line">        outb(inb_p(<span class="number">0xA1</span>)&amp;<span class="number">0xdf</span>,<span class="number">0xA1</span>);   <span class="comment">// 允许从8259A芯片的IRQ13中断请求</span></span><br><span class="line">        set_trap_gate(<span class="number">39</span>,&amp;parallel_interrupt); <span class="comment">// 并口的中断项</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>GDT：</p>
<p>在系统启动的过程中，GDT 被初始化了不止一次。GDT 最后一次在 <code>head.s</code> 中被设置，随后便在系统运行中被一直沿用。</p>
<p>在 <code>head.s</code> 中，采用 <code>lgdt</code> 指令加载预设好的 GDT 表内容。在这里，内核只设置了 GDT 中内核数据段和内核代码段的段描述符，而各个任务的 LDT 和 TSS 段在以后设置。</p>
<p>代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"># 代码路径：boot&#x2F;head.s</span><br><span class="line">setup_gdt:</span><br><span class="line">        lgdt gdt_descr</span><br><span class="line">        ret</span><br><span class="line">......</span><br><span class="line">gdt_descr:</span><br><span class="line">        .word 256*8-1           # so does gdt (not that that&#39;s any</span><br><span class="line">        .long _gdt              # magic number, but it works for me :^)</span><br><span class="line">......</span><br><span class="line">_gdt:	.quad 0x0000000000000000        &#x2F;* NULL descriptor *&#x2F;</span><br><span class="line">        .quad 0x00c09a0000000fff        &#x2F;* 16Mb *&#x2F;</span><br><span class="line">        .quad 0x00c0920000000fff        &#x2F;* 16Mb *&#x2F;</span><br><span class="line">        .quad 0x0000000000000000        &#x2F;* TEMPORARY - don&#39;t use *&#x2F;</span><br><span class="line">        .fill 252,8,0                   &#x2F;* space for LDT&#39;s and TSS&#39;s etc *&#x2F;</span><br></pre></td></tr></table></figure>
<p>最后，在 <code>sched_init</code> 中设置进程 0 的 LDT 段和 TSS 段。注意，进程 0 的 LDT 和 TSS 段的内容是在 <code>sched.h</code> 中预设的固定值。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 代码路径：kernel/sched.c</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sched_init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        ......</span><br><span class="line">        set_tss_desc(gdt+FIRST_TSS_ENTRY,&amp;(init_task.task.tss));</span><br><span class="line">        set_ldt_desc(gdt+FIRST_LDT_ENTRY,&amp;(init_task.task.ldt));</span><br><span class="line">        ......</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>LDT：</p>
<p>对进程 0 来说，LDT 的值是预设的（见下），在 <code>sched_init</code> 中被挂接到 GDT 上（见上）。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 代码路径：include/linux/sched.h</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INIT_TASK \ <span class="comment">// 进程0的ldt和tss预设值</span></span></span><br><span class="line">......</span><br><span class="line">        &#123; \</span><br><span class="line">                &#123;<span class="number">0</span>,<span class="number">0</span>&#125;, \</span><br><span class="line"><span class="comment">/* ldt */</span>       &#123;<span class="number">0x9f</span>,<span class="number">0xc0fa00</span>&#125;, \ <span class="comment">// 代码长 640K，基址 0x0，G=1，D=1，DPL=3，P=1 TYPE=0x0a</span></span><br><span class="line">                &#123;<span class="number">0x9f</span>,<span class="number">0xc0f200</span>&#125;, \ <span class="comment">// 数据长 640K，基址 0x0，G=1，D=1，DPL=3，P=1 TYPE=0x02</span></span><br><span class="line">        &#125;, \</span><br><span class="line"><span class="comment">/*tss*/</span>	&#123;...&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对随后的进程来说，进程的 LDT 是在 <code>fork</code> 的过程中建立的。具体来说，在 <code>copy_process</code> 中内核为每一个新进程建立一套新的 LDT 和 TSS，内容与原进程一样：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 代码路径：kernel/fork.c</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">copy_process</span><span class="params">(...)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        ......</span><br><span class="line">        p-&gt;tss.ldt = _LDT(nr); <span class="comment">// LDT内容与被复制进程一致，但在GDT中占用一个新的entry</span></span><br><span class="line">        set_tss_desc(gdt+(nr&lt;&lt;<span class="number">1</span>)+FIRST_TSS_ENTRY,&amp;(p-&gt;tss));</span><br><span class="line">        set_ldt_desc(gdt+(nr&lt;&lt;<span class="number">1</span>)+FIRST_LDT_ENTRY,&amp;(p-&gt;ldt));</span><br><span class="line">        ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>随后如果有新的进程加载新的可执行程序（例如，开始执行 <code>bash</code>），那么 <code>do_execve</code> 会在加载新程序的同时写入新的 LDT 的内容。</p>
<h3 id="18-CPL、RPL、DPL分别是什么意思？记录在什么位置？"><a href="#18-CPL、RPL、DPL分别是什么意思？记录在什么位置？" class="headerlink" title="18. CPL、RPL、DPL分别是什么意思？记录在什么位置？"></a>18. <strong>CPL、RPL、DPL分别是什么意思？记录在什么位置？</strong></h3><p><strong>CPL</strong>(Current Privilege Level) 指明当前执行程序/例程的特权级，是当前正在执行的代码所在的段的特权级。术语「当前特权级」就是指这个域的值。存在于 <code>%cs</code> 寄存器的低两位（<code>%cs</code> 段寄存器的第 0 和第 1 位）。</p>
<p><strong>RPL</strong>(Request Privilege Level) 确定段选择子的请求特权级，是进程对段访问时的请求权限。RPL 是对于段选择子而言的，每个段选择子有自己的 RPL，它说明的是进程对段访问的请求权限，有点像函数参数。而且RPL对每个段来说不是固定的，两次访问同一段时的RPL可以不同。RPL可能会削弱CPL的作用，例如当前CPL=0的进程要访问一个数据段，它把段选择符中的RPL设为3，这样虽然它对该段仍然只有特权为3的访问权限。存在于段选择子的第 0 和第 1 位</p>
<p><strong>DPL</strong>(Descriptor Privilege Level) 确定描述符的特权级，规定访问该描述符需要的权限级别。对段描述符，是访问这个段需要的特权级；对陷阱们和中断门，就是访问这些门、触发中断需要的特权级。当进程访问一个描述符时，需要进程特权级检查，一般要求 <code>DPL &gt;= max&#123;CPL, RPL&#125;</code>。DPL 存在于段描述符的第二个双字的第 13 和第 14 位。</p>
<div align="center">
<img src="/2022/12/31/Linux-0-11-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%E4%B8%8E%E6%80%9D%E8%80%83%E9%A2%98/seg_descr.jpg" alt="Intel x86 架构中的段描述符格式，DPL 在第二个双字中的第 13 和 14 位[4]" style="zoom:50%;"><br>
</div>

<p>每个描述符的 DPL 固定，而请求时的 RPL 是可变的。只有当 RPL 比 DPL 相同或更高（数值上小于等于）时才能正常访问对应的段。</p>
<p>CPL, RPL, DPL 都是<strong>特权级</strong>。特权级数值越小，对应的特权越大；反之，数值越大，对应的特权越小。x86 体系结构中共设计了 4 级特权级，其中 0 特权级级别最高，意味着对芯片有着完全的掌控，一般由操作系统使用；3 特权级特权最低，只能执行简单的计算而无权染指系统指令，一般被赋予给应用程序使用。在 Linux-0.11 中，只使用了 0 特权级（作为内核特权级）和 3 特权级（供应用程序使用）。</p>
<h3 id="19-在IA-32中，有大约20多个指令只能在-0-特权级下使用，其他的指令，比如-cli，并没有这个约定。奇怪的是，在-Linux-0-11-中，3-特权级的进程代码并不能使用-cli-指令，这是为什么？请解释并给出代码证据。"><a href="#19-在IA-32中，有大约20多个指令只能在-0-特权级下使用，其他的指令，比如-cli，并没有这个约定。奇怪的是，在-Linux-0-11-中，3-特权级的进程代码并不能使用-cli-指令，这是为什么？请解释并给出代码证据。" class="headerlink" title="19. 在IA-32中，有大约20多个指令只能在 0 特权级下使用，其他的指令，比如 cli，并没有这个约定。奇怪的是，在 Linux-0.11 中，3 特权级的进程代码并不能使用 cli 指令，这是为什么？请解释并给出代码证据。"></a>19. 在IA-32中，有大约20多个指令只能在 0 特权级下使用，其他的指令，比如 <code>cli</code>，并没有这个约定。奇怪的是，在 Linux-0.11 中，3 特权级的进程代码并不能使用 <code>cli</code> 指令，这是为什么？请解释并给出代码证据。</h3><p>根据 Intel IA-32 Manual，<code>cli</code> 和 <code>sti</code> 指令与 CPL 和 <code>%eflags[IOPL]</code>（Input/Outpu Previledge Level, 进行IO操作需要的特权级）有关。通过 IOPL 来加以保护 <code>in</code>, <code>ins</code>, <code>out</code>, <code>outs</code>, <code>cli</code>, <code>sti</code>等 I/O 敏感指令，只有 CPL(当前特权级)&lt;=IOPL 才能执行，低特权级访问这些指令将会产生一个一般性保护异常。IOPL 位于 <code>%eflags</code> 的12-13位，仅可通过 <code>iret</code> 和 <code>lmsw</code> 来改变。</p>
<p>操作系统上运行的第一个进程是进程 0，进程 0 的 IOPL 在 TSS 中初始化。<code>INIT_TASK</code> 中指定 <code>%eflags[IOPL]</code> 为0：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 代码路径：include/linux/sched.h</span></span><br><span class="line"><span class="comment">// 赋给进程0的task_struct值</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INIT_TASK \\</span></span><br><span class="line">......</span><br><span class="line"><span class="comment">/*tss*/</span> &#123;<span class="number">0</span>,PAGE_SIZE+(<span class="keyword">long</span>)&amp;init_task,<span class="number">0x10</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,(<span class="keyword">long</span>)&amp;pg_dir,\\</span><br><span class="line">        <span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>, \\</span><br><span class="line">        <span class="comment">//^ tss.eflags的值，=0</span></span><br><span class="line">        ......&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从此之后，所有进程都直接或间接地由内核进程 <code>fork</code> 而来，<code>IOPL</code> 的值仍然为 0 没有改变，也不会改变。所以用户进程无法调用 <code>cli</code> 指令。因此，通过设置 IOPL，3 特权级的进程代码不能使用 <code>cli</code> 等I/O敏感指令。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//代码路径：kernel\\fork.c</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">copy_process</span><span class="params">(<span class="keyword">int</span> nr,<span class="keyword">long</span> ebp,<span class="keyword">long</span> edi,<span class="keyword">long</span> esi,<span class="keyword">long</span> gs,<span class="keyword">long</span> none,</span></span></span><br><span class="line"><span class="function"><span class="params">		<span class="keyword">long</span> ebx,<span class="keyword">long</span> ecx,<span class="keyword">long</span> edx,</span></span></span><br><span class="line"><span class="function"><span class="params">		<span class="keyword">long</span> fs,<span class="keyword">long</span> es,<span class="keyword">long</span> ds,</span></span></span><br><span class="line"><span class="function"><span class="params">		<span class="keyword">long</span> eip,<span class="keyword">long</span> cs,<span class="keyword">long</span> eflags,<span class="keyword">long</span> esp,<span class="keyword">long</span> ss)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        ......</span><br><span class="line">        p-&gt;tss.eip = eip;</span><br><span class="line">        p-&gt;tss.eflags = eflags;</span><br><span class="line">        p-&gt;tss.eax = <span class="number">0</span>;</span><br><span class="line">        ......</span><br><span class="line">        <span class="keyword">return</span> last_pid;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="20-进程-0-的-task-struct-在哪？具体内容是什么？给出代码证据。"><a href="#20-进程-0-的-task-struct-在哪？具体内容是什么？给出代码证据。" class="headerlink" title="20. 进程 0 的 task_struct 在哪？具体内容是什么？给出代码证据。"></a>20. 进程 0 的 <code>task_struct</code> 在哪？具体内容是什么？给出代码证据。</h3><p>这一数据结构在代码上定义于 <code>include/linux/sched.h</code>，而运行时位于内核数据段。具体内容包括状态、信号、pid、alarm、ldt、tss 等管理该进程所需的数据。具体代码见问题 19。</p>
<h3 id="21-在-sched-init-void-函数中有这样的代码，对-task-数组进行了初始化："><a href="#21-在-sched-init-void-函数中有这样的代码，对-task-数组进行了初始化：" class="headerlink" title="21. 在 sched_init(void) 函数中有这样的代码，对 task 数组进行了初始化："></a>21. 在 <code>sched_init(void)</code> 函数中有这样的代码，对 <code>task</code> 数组进行了初始化：</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 代码路径：kernel/sched.c</span></span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;NR_TASKS;i++) &#123;</span><br><span class="line">        task[i] = <span class="literal">NULL</span>;</span><br><span class="line">        p-&gt;a=p-&gt;b=<span class="number">0</span>;</span><br><span class="line">        p++;</span><br><span class="line">        p-&gt;a=p-&gt;b=<span class="number">0</span>;</span><br><span class="line">        p++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>代码并未涉及 <code>task[0]</code>，但从后续代码能感觉到进程 0 的任务结构已被设置，请给出代码证据。</strong></p>
<p>上面的代码将 <code>task[64]</code> 除进程 0 占用的 0 项外的其余 63 项清空，等待随后被设置。其余进程的 <code>task</code> 数据结果都是在 <code>fork</code> 时被拷贝产生的，唯独进程 0 是个例外，它的 <code>task</code> 数据结构是在启动时手动设置的：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 代码路径：kernel/sched.c</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> * <span class="title">task</span>[<span class="title">NR_TASKS</span>] =</span> &#123;&amp;(init_task.task), &#125;;</span><br></pre></td></tr></table></figure>
<p>其中 <code>init_task</code> 是手动设置的进程 0 <code>task</code> 数据结构的值，见 <code>include/linux/sched.h</code>。</p>
<h3 id="22-在-system-h-里读懂代码。这里中断门、陷阱门、系统调用都是通过-set-gate-设置的，用的是同一个嵌入汇编代码，比较明显的差别是-dpl-一个是3，另外两个是0，这是为什么？说明理由。"><a href="#22-在-system-h-里读懂代码。这里中断门、陷阱门、系统调用都是通过-set-gate-设置的，用的是同一个嵌入汇编代码，比较明显的差别是-dpl-一个是3，另外两个是0，这是为什么？说明理由。" class="headerlink" title="22. 在 system.h 里读懂代码。这里中断门、陷阱门、系统调用都是通过 _set_gate 设置的，用的是同一个嵌入汇编代码，比较明显的差别是 dpl 一个是3，另外两个是0，这是为什么？说明理由。"></a>22. 在 <code>system.h</code> 里读懂代码。这里中断门、陷阱门、系统调用都是通过 <code>_set_gate</code> 设置的，用的是同一个嵌入汇编代码，比较明显的差别是 dpl 一个是3，另外两个是0，这是为什么？说明理由。</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _set_gate(gate_addr,type,dpl,addr) \\</span></span><br><span class="line">__asm__ (<span class="string">&quot;movw %%dx,%%ax\\n\\t&quot;</span> \\</span><br><span class="line">        <span class="string">&quot;movw %0,%%dx\\n\\t&quot;</span> \\</span><br><span class="line">        <span class="string">&quot;movl %%eax,%1\\n\\t&quot;</span> \\</span><br><span class="line">        <span class="string">&quot;movl %%edx,%2&quot;</span> \\</span><br><span class="line">        : \\</span><br><span class="line">        : <span class="string">&quot;i&quot;</span> ((<span class="keyword">short</span>) (<span class="number">0x8000</span>+(dpl&lt;&lt;<span class="number">13</span>)+(type&lt;&lt;<span class="number">8</span>))), \\</span><br><span class="line">        <span class="string">&quot;o&quot;</span> (*((<span class="keyword">char</span> *) (gate_addr))), \\</span><br><span class="line">        <span class="string">&quot;o&quot;</span> (*(<span class="number">4</span>+(<span class="keyword">char</span> *) (gate_addr))), \\</span><br><span class="line">        <span class="string">&quot;d&quot;</span> ((<span class="keyword">char</span> *) (addr)),<span class="string">&quot;a&quot;</span> (<span class="number">0x00080000</span>))</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> set_intr_gate(n,addr) \\</span></span><br><span class="line">        _set_gate(&amp;idt[n],<span class="number">14</span>,<span class="number">0</span>,addr)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> set_trap_gate(n,addr) \\</span></span><br><span class="line">        _set_gate(&amp;idt[n],<span class="number">15</span>,<span class="number">0</span>,addr)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> set_system_gate(n,addr) \\</span></span><br><span class="line">        _set_gate(&amp;idt[n],<span class="number">15</span>,<span class="number">3</span>,addr)</span><br></pre></td></tr></table></figure>
<p><code>set_trap_gate</code> 和 <code>set_intr_gate</code> 参数中的 <code>dpl</code> 是 <code>3</code>，<code>set_system_gate</code>的 <code>dpl</code> 是 <code>0</code>。dpl 为 0 表示只能在内核态下允许，dpl 为 3 表示系统调用可以由 3 特权级调用。 当用户程序产生系统调用软中断后， 系统都通过 <code>system_call</code> 总入口找到具体的系统调用函数。 <code>set_system_gate</code> 设置系统调用，须将 <code>DPL</code> 设置为 <code>3</code>，允许在用户特权级(=3)的进程调用，否则会引发保护异常。<code>set_trap_gate</code> 及 <code>set_intr_gate</code> 设置陷阱和中断为内核使用，需禁止用户进程调用，所以 DPL 为 0。</p>
<h3 id="23-在-Linux-操作系统中大量使用了中断、异常类的处理，究竟有什么好处？"><a href="#23-在-Linux-操作系统中大量使用了中断、异常类的处理，究竟有什么好处？" class="headerlink" title="23. 在 Linux 操作系统中大量使用了中断、异常类的处理，究竟有什么好处？"></a>23. 在 Linux 操作系统中大量使用了中断、异常类的处理，究竟有什么好处？</h3><p>在未引入中断、异常处理理念以前，CPU 采用轮询 (polling) 的方法处理外部信号：CPU 每隔一段时间就要对全部硬件进行轮询，以检测它的工做是否完成，若是没有完成就继续轮询。这样消耗了CPU处理用户程序的时间，下降了系统的综合效率。CPU以“主动轮询”的方式来处理信号是很不划算的。</p>
<p>自 IBM 兼容机以后，系统以“被动模式”代替“主动轮询”来处理终端问题。进程在主机中运算需用到 CPU，其中可能进行“异常处理”，此时需要具体的服务程序来执行。这种中断服务体系的建立是为了被动响应中断信号。因此，CPU 就可以更高效的处理用户程序服务，不用考虑随机可能产生的中断信号，从而提高了操作系统的综合效率。</p>
<h3 id="24-进程-0-fork-进程-1-之前，为什么先调用-move-to-user-mode-？用的是什么方法？解释其中的道理。"><a href="#24-进程-0-fork-进程-1-之前，为什么先调用-move-to-user-mode-？用的是什么方法？解释其中的道理。" class="headerlink" title="24. 进程 0 fork 进程 1 之前，为什么先调用 move_to_user_mode()？用的是什么方法？解释其中的道理。"></a>24. 进程 0 <code>fork</code> 进程 1 之前，为什么先调用 <code>move_to_user_mode()</code>？用的是什么方法？解释其中的道理。</h3><p>Linux 规定，除了进程 0 外，所有进程都要由一个已有的进程在 3 特权级下创建，进程 0 此时处于 0 特权级。按照规定，在创建进程 1 之前要将进程 0 转变为 3 特权级。方法是调用 <code>move_to_user_mode()</code> 函数，模仿中断返回动作，实现进程 0 的特权级从内核态转化为用户态。又因为在 Linux-0.11 中，转换特权级时采用中断和中断返回的方式，调用系统中断实现从 3 到 0 的特权级转换，中断返回时转换为 3 特权级。因此，进程 0 从 0 特权级到 3 特权级转换时采用的是模仿中断返回。设计者首先手工写压栈代码模拟 <code>int</code>（中断）压栈，当执行 <code>iret</code> 指令时，CPU 自动将这 5 个寄存器的值 (<code>%ss, %esp, %eflags, %cs, %eip</code>) 按序恢复给 CPU，CPU 就会翻转到 3 特权级去执行代码。</p>
<h3 id="25-为什么-static-inline-syscall0-type-name-中需要加上关键字-inline？"><a href="#25-为什么-static-inline-syscall0-type-name-中需要加上关键字-inline？" class="headerlink" title="25. 为什么 static inline _syscall0(type,name) 中需要加上关键字 inline？"></a>25. <strong>为什么 <code>static inline _syscall0(type,name)</code> 中需要加上关键字 <code>inline</code>？</strong></h3><p>这一问题的答案藏在写时复制 (CoW, Copy on Write) 机制中。</p>
<p><code>fork</code> 函数会复制进程的页表，并将父进程和子进程的页表项都标记为只读，从而便于随后实现写时复制功能。具体来说，进程试图读取只读页的时候会产生保护异常，操作系统便在处理异常时拷贝一份新的物理页供进程修改。但 CoW 机制有一个例外：当页在内核空间（1M以下的地址）时，不会进行写时复制，而是允许内核之间共享内存叶。导致这一行为的代码见 <code>copy_page_tables(...)</code> 函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 代码路径 mm/memory.c/copy_page_tables(...)</span></span><br><span class="line">......</span><br><span class="line"><span class="comment">// 对所有（要被拷贝的）页表项：</span></span><br><span class="line"><span class="keyword">for</span> ( ; nr-- &gt; <span class="number">0</span> ; from_page_table++,to_page_table++) &#123;</span><br><span class="line">        this_page = *from_page_table; <span class="comment">// this_page 指向一个页表项，而非物理页</span></span><br><span class="line">        <span class="keyword">if</span> (!(<span class="number">1</span> &amp; this_page))</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">        this_page &amp;= ~<span class="number">2</span>; <span class="comment">// 将页表项 R/W 位复位（置0，只读）</span></span><br><span class="line">        *to_page_table = this_page; <span class="comment">// 写到目的页表项</span></span><br><span class="line">        <span class="keyword">if</span> (this_page &gt; LOW_MEM) &#123; <span class="comment">// !!仅当该页高于 1M 时触发如下代码!!</span></span><br><span class="line">                <span class="comment">// 将 R/W 复位的（只读的）页表项覆盖原页表项</span></span><br><span class="line">                <span class="comment">// 即将父进程的页表项也设为只读</span></span><br><span class="line">                *from_page_table = this_page; </span><br><span class="line">                this_page -= LOW_MEM;</span><br><span class="line">                this_page &gt;&gt;= <span class="number">12</span>;</span><br><span class="line">                <span class="comment">// 并标记该页被共享了（为写时复制准备）</span></span><br><span class="line">                mem_map[this_page]++;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line">......</span><br></pre></td></tr></table></figure>
<p>进程 0 创建进程 1 后，二者共享物理页；然而由于栈和数据段位于内核区，<strong>如果进程 0 修改栈和数据段，不会触发写时复制，而是会在原有物理页上直接修改，这将破坏进程 1 的内存空间。为此，Linus 给出了解决方案：让进程 0 在 <code>fork()</code> 之后不修改任何数据和栈。</strong></p>
<p><code>_syscall0(int, fork)</code> 展开之后是一个真正的 C 函数声明。如果进程 0 直接调用这样的函数，那么势必会使用栈，从而破坏进程 1 的栈。为此，Linus Torvalds 在声明中加入了 <code>inline</code> 关键字，让编译器在 <code>main</code> 中原地展开函数声明。这样一来，运行时中就不会进行函数调用，也不会改变栈的内容，从而避免了破坏进程 1 的栈。</p>
<p>“函数调用”意味着什么呢？在汇编层次上，函数调用意味着 <code>call</code> 和 <code>ret</code> 指令。普通函数调用时需要使用 <code>call</code> 将 <code>%eip</code> 入栈（并跳转），返回时需要使用 <code>ret</code> 将 <code>%eip</code> 出栈，这都会修改栈的内容。<code>inline</code> 意味着内联函数，它将标明为 <code>inline</code> 的函数代码放在符号表中；此处的 <code>fork</code> 函数加上 <code>inline</code> 后先进行词法分析、语法分析后在编译时就地展开函数，不需要普通函数的 <code>call\ret</code> 指令，也不需要保持栈的 <code>%eip</code>。</p>
<p>若不加上 <code>inline</code>，（进程 0 中）第一次返回 <code>fork</code> 结束时会将 <code>%eip</code> 出栈，在 <code>pause</code> 时又将新的返回地址压入栈中。经过 <code>pause</code> 之后进程 1 才被调度执行，而此时的栈段已经被进程 0 修改过了，（进程 1 中）第二次 <code>fork()</code> 返回时 <code>%eip</code> 的出栈值将是一个错误值。 </p>
<h3 id="26-缺页中断是如何产生的，页写保护中断是如何产生的，操作系统是如何处理的？"><a href="#26-缺页中断是如何产生的，页写保护中断是如何产生的，操作系统是如何处理的？" class="headerlink" title="26. 缺页中断是如何产生的，页写保护中断是如何产生的，操作系统是如何处理的？"></a>26. <strong>缺页中断是如何产生的，页写保护中断是如何产生的，操作系统是如何处理的？</strong></h3><p>在 Intel x86 体系结果中，严格来说没有“缺页中断”，只有“页故障”(#PF, page fault)，和页故障导致的软中断。缺页故障和页写保护故障分别是页故障的两种不同情况，由故障产生时的 error code 区分。</p>
<p>Linux-0.11 中，#PF 由 <code>page.s</code> 中的 <code>_page_fault</code> 进行初步处理，根据不同 error code 分别转交给 <code>do_no_page</code> （缺页故障）和 <code>do_wp_page</code> （页写保护故障）作进一步处理。</p>
<p><strong>① 缺页故障</strong></p>
<p>每一个页目录项或页表项的低 3 位，<code>U/S</code>, <code>R/W</code>, <code>P</code>，记录着所管理的页面的属性。如果页目录项或页表项指向的页存在于物理内存中，则 <code>P</code> 标志就设置为 <code>1</code>，反之则为 <code>0</code>。进程执行时，线性地址由 MMU 负责解析，如果解析发现某个表项的 <code>P</code> 位为 <code>0</code>，则说明没有对应页面，便会产生缺页中断。操作系统会调用 <code>do_no_page</code> 处理缺页故障：为进程申请空闲物理页，将程序加载到新分配的物理页中，并更新对应的页目录项和页表项。</p>
<p><strong>② 页写保护故障</strong></p>
<p>若某个进程试图访问一个只读页面（<code>R/W</code> 为 <code>0</code>），便会产生一个页写保护故障。这种情况往往是由于采用了 CoW（写时复制，Copy on Write）策略、两个（或多个）进程共享一个页面导致的。在 <code>copy_page_tables</code> 函数中，操作系统会将被两个进程共享的页面标记为只读。任何一个进程试图修改只读页时，便会触发页写保护故障，这便是两个（或多个）进程共享一个页面的具体原理。检测到页写保护故障后，操作系统会调用 <code>do_wp_page</code> 实现写时复制策略：为当前进程申请空闲物理页，将将原页面的数据复制到新页面中，然后将该进程的页表项指向新申请的页面，同时将原页面的引用计数减 1。当前进程得到自己的页面，就可以执行写操作。</p>
<h2 id="Part-II-多任务与进程调度"><a href="#Part-II-多任务与进程调度" class="headerlink" title="Part II 多任务与进程调度"></a>Part II 多任务与进程调度</h2><h3 id="27-copy-process-函数的参数最后五项是：long-eip-long-cs-long-eflags-long-esp-long-ss。查看栈结构确实有这五个参数，奇怪的是其他参数的压栈代码都能找得到，确找不到这五个参数的压栈代码，反汇编代码中也查不到，请解释原因。"><a href="#27-copy-process-函数的参数最后五项是：long-eip-long-cs-long-eflags-long-esp-long-ss。查看栈结构确实有这五个参数，奇怪的是其他参数的压栈代码都能找得到，确找不到这五个参数的压栈代码，反汇编代码中也查不到，请解释原因。" class="headerlink" title="27. copy_process 函数的参数最后五项是：long eip,long cs, long eflags, long esp, long ss。查看栈结构确实有这五个参数，奇怪的是其他参数的压栈代码都能找得到，确找不到这五个参数的压栈代码，反汇编代码中也查不到，请解释原因。"></a>27. <code>copy_process</code> 函数的参数最后五项是：<code>long eip,long cs, long eflags, long esp, long ss</code>。查看栈结构确实有这五个参数，奇怪的是其他参数的压栈代码都能找得到，确找不到这五个参数的压栈代码，反汇编代码中也查不到，请解释原因。</h3><p><code>copy_process</code> 执行是因为进程调用了 <code>fork</code> 函数创建进程，会执行 <code>int 0x80</code> 产生一个软中断。参考 Intel IA-32 手册可知，中断使 CPU 硬件自动将 <code>%ss, %esp, %eflags, %cs, %eip</code> 这5个寄存器的值按顺序压入进程0的内核栈。又因为函数传递参数是使用栈的，所以刚好可以作为 <code>copy_process</code>的 最后五个参数。</p>
<h3 id="28-根据代码详细说明-copy-process-函数的所有参数是如何形成的？"><a href="#28-根据代码详细说明-copy-process-函数的所有参数是如何形成的？" class="headerlink" title="28. 根据代码详细说明 copy_process 函数的所有参数是如何形成的？"></a>28. <strong>根据代码详细说明 <code>copy_process</code> 函数的所有参数是如何形成的？</strong></h3><p><code>copy_process</code> 函数原型为：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">copy_process</span><span class="params">(<span class="keyword">int</span> nr,<span class="keyword">long</span> ebp,<span class="keyword">long</span> edi,<span class="keyword">long</span> esi,<span class="keyword">long</span> gs,<span class="keyword">long</span> none,</span></span></span><br><span class="line"><span class="function"><span class="params">                <span class="keyword">long</span> ebx,<span class="keyword">long</span> ecx,<span class="keyword">long</span> edx,</span></span></span><br><span class="line"><span class="function"><span class="params">                <span class="keyword">long</span> fs,<span class="keyword">long</span> es,<span class="keyword">long</span> ds,</span></span></span><br><span class="line"><span class="function"><span class="params">                <span class="keyword">long</span> eip,<span class="keyword">long</span> cs,<span class="keyword">long</span> eflags,<span class="keyword">long</span> esp,<span class="keyword">long</span> ss)</span></span></span><br></pre></td></tr></table></figure>
<p>与一般的函数不同，<code>copy_process</code> 的参数不是由 C 语言中的传参机制传递的，而是由汇编代码“做”出来的。函数参数的本质是调用子程序时的栈上数据，而 <code>copy_process</code> 函数的所有参数正是通过汇编代码压栈形成的。</p>
<p>参数有很多，我们将其分为几组，分组进行讨论。</p>
<p>① <code>long eip, long cs, long eflags, long esp, long ss</code> 这五个参数是中断使 CPU 自动压栈的。参考 x86 手册 (Intel IA-32 Manual) 可知，在中断时芯片会自动将当前的 <code>%eip, %cs, %eflags</code> 压入栈中，便于从中断处理程序返回到原来执行处。如果中断时切换了特权级，还会将 <code>%esp</code> 和<code>%ss</code> 压入栈中，并切换栈。</p>
<p>系统调用是从 3 特权级的用户态向 0 特权级的内核态的切换，因此会触发后一种压栈，形成了 <code>copy_process</code> 的后五个参数。</p>
<div align="center">
<img src="/2022/12/31/Linux-0-11-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%E4%B8%8E%E6%80%9D%E8%80%83%E9%A2%98/stack_change_on_int.png" alt="IA-32 CPU在中断时的自动压栈[4]" style="zoom:50%;"><br>
</div>


<p>② <code>long ebx, long ecx, long edx, long fs, long es, long ds</code> 是在汇编代码中压进栈的参数。 </p>
<p>③ <code>long none</code> 是一个无用参数，起占位符作用。 为 <code>_system_call</code> 调用 <code>_sys_fork</code> 时压进栈的 <code>%eip</code> 值。</p>
<p>④ <code>int nr</code> 是 <code>_system_fork</code> 压入栈的值，也是 <code>find_empty_process</code> 函数的返回值。这个值是 <code>task</code> 数组中下一个空槽位的索引。</p>
<p>⑤ <code>long ebp, long edi, long esi, long gs</code> 是 <code>_system_fork</code> 压入栈的参数。 </p>
<p>不难发现，除了 <code>int nr</code> 和 <code>int none</code> 之外，其余的参数都对应了用户态程序调用 <code>fork</code> 之前的寄存器值。这些寄存器值被传递给 <code>copy_process</code>，是为了被拷贝到新进程。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 代码路径：kernel&#x2F;system_call.s</span><br><span class="line">......</span><br><span class="line">_system_call:</span><br><span class="line">        &#x2F;&#x2F; 此时 %eip 等五个寄存器已经在栈上（第一组参数）</span><br><span class="line">        cmpl $nr_system_calls-1,%eax</span><br><span class="line">        ja bad_sys_call</span><br><span class="line">        &#x2F;&#x2F; 将第二组六个参数压入栈</span><br><span class="line">        push %ds</span><br><span class="line">        push %es</span><br><span class="line">        push %fs</span><br><span class="line">        pushl %edx</span><br><span class="line">        pushl %ecx              # push %ebx,%ecx,%edx as parameters</span><br><span class="line">        pushl %ebx              # to the system call</span><br><span class="line">        movl $0x10,%edx         # set up ds,es to kernel space</span><br><span class="line">        mov %dx,%ds</span><br><span class="line">        mov %dx,%es</span><br><span class="line">        movl $0x17,%edx         # fs points to local data space</span><br><span class="line">        mov %dx,%fs</span><br><span class="line">        &#x2F;&#x2F; 跳转指令会将 %eip 压栈，在栈上占用一个空间。</span><br><span class="line">        &#x2F;&#x2F; copy_process设置了一个int none参数来为这个位置预留空间。</span><br><span class="line">        call _sys_call_table(,%eax,4)</span><br><span class="line">        pushl %eax</span><br><span class="line">        movl _current,%eax</span><br><span class="line">        cmpl $0,state(%eax)             # state</span><br><span class="line">        jne reschedule</span><br><span class="line">        cmpl $0,counter(%eax)           # counter</span><br><span class="line">        je reschedule</span><br><span class="line"></span><br><span class="line">......</span><br><span class="line"></span><br><span class="line">_sys_fork:</span><br><span class="line">        &#x2F;&#x2F; 调用find_empty_process函数寻找下一个空的任务槽位</span><br><span class="line">        &#x2F;&#x2F; 返回值留在栈中，形成了copy_process的int nr参数</span><br><span class="line">        call _find_empty_process</span><br><span class="line">        testl %eax,%eax</span><br><span class="line">        js 1f</span><br><span class="line">        &#x2F;&#x2F; 将第五组参数压入栈</span><br><span class="line">        push %gs</span><br><span class="line">        pushl %esi</span><br><span class="line">        pushl %edi</span><br><span class="line">        pushl %ebp</span><br><span class="line">        pushl %eax</span><br><span class="line">        call _copy_process</span><br><span class="line">        addl $20,%esp</span><br><span class="line">1:      ret</span><br></pre></td></tr></table></figure>
<h3 id="29-进程-0-创建进程-1-时调用-copy-process-函数，在其中直接、间接调用了两次-get-free-page-函数，在物理内存中获得了两个页，分别用作什么？是怎么设置的？给出代码证据。"><a href="#29-进程-0-创建进程-1-时调用-copy-process-函数，在其中直接、间接调用了两次-get-free-page-函数，在物理内存中获得了两个页，分别用作什么？是怎么设置的？给出代码证据。" class="headerlink" title="29. 进程 0 创建进程 1 时调用 copy_process 函数，在其中直接、间接调用了两次 get_free_page 函数，在物理内存中获得了两个页，分别用作什么？是怎么设置的？给出代码证据。"></a>29. <strong>进程 0 创建进程 1 时调用 <code>copy_process</code> 函数，在其中直接、间接调用了两次 <code>get_free_page</code> 函数，在物理内存中获得了两个页，分别用作什么？是怎么设置的？给出代码证据。</strong></h3><p>第一次调用 <code>get_free_page</code> 函数申请的空闲页面用于进程 1 的 <code>task_struct</code> 及内核栈。首先将申请到的页面清0，然后复制进程 0 的 <code>task_struct</code>，再针对进程 1 作微调。其中 <code>esp0</code> 的设置，意味着设置该页末尾为进程 1 的内核栈的起始地址。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 代码路径：kernel/fork.c</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">copy_process</span><span class="params">(<span class="keyword">int</span> nr,<span class="keyword">long</span> ebp,<span class="keyword">long</span> edi,<span class="keyword">long</span> esi,<span class="keyword">long</span> gs,<span class="keyword">long</span> none,</span></span></span><br><span class="line"><span class="function"><span class="params">                <span class="keyword">long</span> ebx,<span class="keyword">long</span> ecx,<span class="keyword">long</span> edx,</span></span></span><br><span class="line"><span class="function"><span class="params">                <span class="keyword">long</span> fs,<span class="keyword">long</span> es,<span class="keyword">long</span> ds,</span></span></span><br><span class="line"><span class="function"><span class="params">                <span class="keyword">long</span> eip,<span class="keyword">long</span> cs,<span class="keyword">long</span> eflags,<span class="keyword">long</span> esp,<span class="keyword">long</span> ss)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        ......</span><br><span class="line">        p = (struct task_struct *) get_free_page(); <span class="comment">// HERE!</span></span><br><span class="line">        <span class="keyword">if</span> (!p)</span><br><span class="line">                <span class="keyword">return</span> -EAGAIN;</span><br><span class="line">        task[nr] = p;</span><br><span class="line">        *p = *current;	<span class="comment">/* NOTE! this doesn&#x27;t copy the supervisor stack */</span></span><br><span class="line">        ......</span><br><span class="line">        p-&gt;tss.esp0 = PAGE_SIZE + (<span class="keyword">long</span>) p; <span class="comment">// 被复制进程的0特权级栈（即内核栈）的起始地址</span></span><br><span class="line">        ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第二次调用 <code>get_free_page</code> 函数申请的空闲页面用作进程 1 的页表。在创建进程1执行 <code>copy_process</code> 中，执行 <code>copy_mem(nr,p)</code> 时，内核为进程 1 拷贝了进程 0 的页表（对进程 0 -&gt;进程 1而言只拷贝 160 页表项，否则会拷贝 256 项），同时将页表项的属性修改为只读。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 代码路径：mm/memory.c</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">copy_page_tables</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">long</span> from,<span class="keyword">unsigned</span> <span class="keyword">long</span> to,<span class="keyword">long</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        ......</span><br><span class="line">        <span class="comment">// size = #要复制的页目录项 = #要复制的页表数</span></span><br><span class="line">        size = ((<span class="keyword">unsigned</span>) (size+<span class="number">0x3fffff</span>)) &gt;&gt; <span class="number">22</span>; </span><br><span class="line">        <span class="keyword">for</span>( ; size--&gt;<span class="number">0</span> ; from_dir++,to_dir++) &#123;</span><br><span class="line">                <span class="comment">// from|to_page_table是指向页表所在页的指针</span></span><br><span class="line">                from_page_table = (<span class="keyword">unsigned</span> <span class="keyword">long</span> *) (<span class="number">0xfffff000</span> &amp; *from_dir);</span><br><span class="line">                <span class="comment">// HERE! 用get_free_page获得新页作为页表</span></span><br><span class="line">                <span class="keyword">if</span> (!(to_page_table = (<span class="keyword">unsigned</span> <span class="keyword">long</span> *) get_free_page()))</span><br><span class="line">                        <span class="keyword">return</span> <span class="number">-1</span>;	<span class="comment">/* Out of memory, see freeing */</span></span><br><span class="line">                *to_dir = ((<span class="keyword">unsigned</span> <span class="keyword">long</span>) to_page_table) | <span class="number">7</span>;</span><br><span class="line">        &#125;</span><br><span class="line">		......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="30-分析-get-free-page-函数的代码，叙述在主内存中获取一个空闲页的技术路线。"><a href="#30-分析-get-free-page-函数的代码，叙述在主内存中获取一个空闲页的技术路线。" class="headerlink" title="30. 分析 get_free_page() 函数的代码，叙述在主内存中获取一个空闲页的技术路线。"></a>30. 分析 <code>get_free_page()</code> 函数的代码，叙述在主内存中获取一个空闲页的技术路线。</h3><ol>
<li>通过逆向扫描页表位图 <code>mem_map</code>，找到内存中（从高地址开始）第一个空闲（字节为0）页面，将其在<code>mem_map</code>中对应的位置置为1。</li>
<li><code>%ecx</code> 左移12位加 <code>LOW_MEM</code> 获得该页的物理地址，并将页面清零。</li>
<li>最后返回空闲页面物理内存的起始地址。</li>
</ol>
<p>值得注意的是，代码中利用了x86架构提供的字符串批处理指令 (<code>scasb, stosl</code>)，以简化代码、加快速度。</p>
<p>代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 代码路径：mm/memory.c</span></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="title">get_free_page</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">register</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> __res <span class="title">asm</span><span class="params">(<span class="string">&quot;ax&quot;</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">__asm__(<span class="string">&quot;std ; repne ; scasb\\n\\t&quot;</span></span><br><span class="line">        <span class="string">&quot;jne 1f\\n\\t&quot;</span></span><br><span class="line">        <span class="string">&quot;movb $1,1(%%edi)\\n\\t&quot;</span></span><br><span class="line">        <span class="string">&quot;sall $12,%%ecx\\n\\t&quot;</span></span><br><span class="line">        <span class="string">&quot;addl %2,%%ecx\\n\\t&quot;</span></span><br><span class="line">        <span class="string">&quot;movl %%ecx,%%edx\\n\\t&quot;</span></span><br><span class="line">        <span class="string">&quot;movl $1024,%%ecx\\n\\t&quot;</span></span><br><span class="line">        <span class="string">&quot;leal 4092(%%edx),%%edi\\n\\t&quot;</span></span><br><span class="line">        <span class="string">&quot;rep ; stosl\\n\\t&quot;</span></span><br><span class="line">        <span class="string">&quot;movl %%edx,%%eax\\n&quot;</span></span><br><span class="line">        <span class="string">&quot;1:&quot;</span></span><br><span class="line">        :<span class="string">&quot;=a&quot;</span> (__res)</span><br><span class="line">        :<span class="string">&quot;0&quot;</span> (<span class="number">0</span>),<span class="string">&quot;i&quot;</span> (LOW_MEM),<span class="string">&quot;c&quot;</span> (PAGING_PAGES),</span><br><span class="line">        <span class="string">&quot;D&quot;</span> (mem_map+PAGING_PAGES<span class="number">-1</span>)</span><br><span class="line">        :<span class="string">&quot;di&quot;</span>,<span class="string">&quot;cx&quot;</span>,<span class="string">&quot;dx&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> __res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="31-为什么-get-free-page-将新分配的页面清-0？"><a href="#31-为什么-get-free-page-将新分配的页面清-0？" class="headerlink" title="31. 为什么 get_free_page() 将新分配的页面清 0？"></a>31. <strong>为什么 <code>get_free_page()</code> 将新分配的页面清 0？</strong></h3><p>因为无法预知该内存页的用途，如果用作页表，不清零就有垃圾值，就是隐患。 </p>
<p>Linux 在回收页面时并不会将页面清 0，只是将 <code>mem_map</code> 中与该页对应的引用计数置 0。在使用 <code>get_free_page</code> 申请内存页时，便是遍历 <code>mem_map</code> 寻找引用计数为 0 的页，但是该页可能存在垃圾数据，如果不清 0 的话，若将该页用做页表，则可能导致错误的映射，引发错误，所以要将新分配的页面清0。</p>
<h3 id="32-copy-mem-和-copy-page-tables-在第一次调用时是如何运行的？"><a href="#32-copy-mem-和-copy-page-tables-在第一次调用时是如何运行的？" class="headerlink" title="32. copy_mem() 和 copy_page_tables() 在第一次调用时是如何运行的？"></a>32. <strong><code>copy_mem()</code> 和 <code>copy_page_tables()</code> 在第一次调用时是如何运行的？</strong></h3><p><code>copy_mem()</code> 在进程 0 创建进程 1 时被第一次调用，它的作用是拷贝进程的内存管理框架，设置进程 1 的段描述符。它先提取当前进程（进程0）的代码段、数据段的段限长，并将当前进程（进程0）的段限长赋值给子进程（进程1）的段限长。然后提取当前进程（进程0）的代码段、数据段的段基址，检查当前进程（进程0）的段基址、段限长是否有问题。接着设置子进程（进程1）的 LDT 段描述符中代码段和数据段的基地址为 nr(=1)*64MB。最后调用 <code>copy_page_tables()</code> 函数，进行具体的页表拷贝。</p>
<p><code>copy_page_tables()</code> 的作用是拷贝进程的页目录项和全部页目录表，但不拷贝物理页。该函数的参数是源地址、目的地址和大小，<strong>首先</strong>检测源地址和目的地址是否都是 4MB 的整数倍，如不是则报错，不符合分页要求。<strong>然后</strong>取源地址和目的地址所对应的页目录项地址，检测如目的地址所对应的页目录表项已被使用则报错，其中源地址不一定是连续使用的，所以有不存在的跳过。<strong>接着</strong>，取源地址对应的页表地址，并为目的地址申请一个新页作为子进程的页表。<strong>然后</strong>，判断源地址是否为 0，即父进程是否为进程 0 ，如果是，则复制160个页表（~640KB），否则复制1024个页表（~4MB）。<strong>最后</strong>将源页表项复制给目的页表。按理说源页表项和目的页表项都应将对应的页标记为“只读”、方便后续进行写时复制操作，但由于是第一次调用，所以父进程是0，都在1M内，所以不参与写时复制，也不维护引用计数 <code>mem_map</code>。1M内的内核区不参与用户分页管理。对 <code>copy_page_tables</code> 函数的具体分析见问题 33。</p>
<h3 id="33-分析-copy-page-tables-函数的代码，叙述父进程如何为子进程复制页表。"><a href="#33-分析-copy-page-tables-函数的代码，叙述父进程如何为子进程复制页表。" class="headerlink" title="33. 分析 copy_page_tables() 函数的代码，叙述父进程如何为子进程复制页表。"></a>33. 分析 <code>copy_page_tables()</code> 函数的代码，叙述父进程如何为子进程复制页表。</h3><p>进入 <code>copy_page_tables</code> 函数后，先为新的页表申请一个空闲页面，并把进程 0 中第一个页表里的前 160 个页表项复制到这个页面中（1个页表项控制一个页面 4KB 内存空间，160个页表项能够控制 640KB 内存空间）。进程0和进程1的页表暂时度指向了相同的页面，意味着进程1也能够操做进程0的页面。以后对进程1的页目录表进行设置。最后，用重置 <code>%cr3</code> 的方法刷新页面变换高速缓存 (TLB)。进程 1 的页表和页目录表设置完毕。进程 1 此时是一个空架子，尚未对应的程序，它的页表又是从进程 0 的页表复制过来的，它们管理的页面彻底一致，也就是它暂时和进程 0 共享一套页面管理结构。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 代码路径：kernel/fork.c</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">copy_mem</span><span class="params">(<span class="keyword">int</span> nr,struct task_struct * p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        ......</span><br><span class="line">        set_base(p-&gt;ldt[<span class="number">1</span>],new_code_base); <span class="comment">// 设置子进程代码段基址</span></span><br><span class="line">        set_base(p-&gt;ldt[<span class="number">2</span>],new_data_base); <span class="comment">// 设置子进程数据段基址</span></span><br><span class="line">        <span class="comment">// 为进程1创建第一个页表、复制进程0的页表，设置进程1的页目录项</span></span><br><span class="line">        <span class="keyword">if</span> (copy_page_tables(old_data_base,new_data_base,data_limit)) &#123;</span><br><span class="line">                free_page_tables(new_data_base,data_limit);</span><br><span class="line">                <span class="keyword">return</span> -ENOMEM;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 代码路径：mm/memory.c</span></span><br><span class="line">......</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> invalidate()\\</span></span><br><span class="line">__asm__(<span class="string">&quot;movl%%eax，%%cr3&quot;</span>：<span class="string">&quot;a&quot;</span>(<span class="number">0</span>) <span class="comment">// 重置CR3为0，从而强制刷新TLB缓存</span></span><br><span class="line">......</span><br><span class="line"><span class="keyword">int</span> copy_page_tables(<span class="keyword">unsigned</span> <span class="keyword">long</span> from,<span class="keyword">unsigned</span> <span class="keyword">long</span> to,<span class="keyword">long</span> size)</span><br><span class="line">&#123;</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">long</span> * from_page_table;</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">long</span> * to_page_table;</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">long</span> this_page;</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">long</span> * from_dir, * to_dir;</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">long</span> nr;</span><br><span class="line">    </span><br><span class="line">		<span class="comment">// 0x3fffff = 4MB = 一个页表的管辖范围</span></span><br><span class="line">    	<span class="comment">// 以下一行代码要求from和to的低22位全为零，即要求地址from和to能被4MB整除</span></span><br><span class="line">        <span class="keyword">if</span> ((from&amp;<span class="number">0x3fffff</span>) || (to&amp;<span class="number">0x3fffff</span>))</span><br><span class="line">                panic(<span class="string">&quot;copy_page_tables called with wrong alignment&quot;</span>);</span><br><span class="line"></span><br><span class="line">    	<span class="comment">// 一个页表管辖4MB =&gt; from/4MB = 对应页表编号 = from&gt;&gt;22</span></span><br><span class="line">		<span class="comment">// 一个页目录表项4B =&gt; (页表编号)*4B = 页目录表项地址 = ((from)&gt;&gt;22)&lt;&lt;2</span></span><br><span class="line">    	<span class="comment">// 化简：((from)&gt;&gt;22)&lt;&lt;2 = (from&gt;&gt;20) 并置低2位为0 = (from&gt;&gt;20)&amp;0xffc</span></span><br><span class="line">        from_dir = (<span class="keyword">unsigned</span> <span class="keyword">long</span> *) ((from&gt;&gt;<span class="number">20</span>) &amp; <span class="number">0xffc</span>); <span class="comment">/* _pg_dir = 0 */</span></span><br><span class="line">        to_dir = (<span class="keyword">unsigned</span> <span class="keyword">long</span> *) ((to&gt;&gt;<span class="number">20</span>) &amp; <span class="number">0xffc</span>);</span><br><span class="line">    </span><br><span class="line">        size = ((<span class="keyword">unsigned</span>) (size+<span class="number">0x3fffff</span>)) &gt;&gt; <span class="number">22</span>;</span><br><span class="line">        <span class="keyword">for</span>( ; size--&gt;<span class="number">0</span> ; from_dir++,to_dir++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="number">1</span> &amp; *to_dir)</span><br><span class="line">                        panic(<span class="string">&quot;copy_page_tables: already exist&quot;</span>);</span><br><span class="line">                <span class="keyword">if</span> (!(<span class="number">1</span> &amp; *from_dir))</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                from_page_table = (<span class="keyword">unsigned</span> <span class="keyword">long</span> *) (<span class="number">0xfffff000</span> &amp; *from_dir);</span><br><span class="line">                <span class="keyword">if</span> (!(to_page_table = (<span class="keyword">unsigned</span> <span class="keyword">long</span> *) get_free_page()))</span><br><span class="line">                        <span class="keyword">return</span> <span class="number">-1</span>;	<span class="comment">/* Out of memory, see freeing */</span></span><br><span class="line">                *to_dir = ((<span class="keyword">unsigned</span> <span class="keyword">long</span>) to_page_table) | <span class="number">7</span>;</span><br><span class="line">                nr = (from==<span class="number">0</span>)?<span class="number">0xA0</span>:<span class="number">1024</span>;</span><br><span class="line">                <span class="keyword">for</span> ( ; nr-- &gt; <span class="number">0</span> ; from_page_table++,to_page_table++) &#123;</span><br><span class="line">                        this_page = *from_page_table;</span><br><span class="line">                        <span class="keyword">if</span> (!(<span class="number">1</span> &amp; this_page))</span><br><span class="line">                                <span class="keyword">continue</span>;</span><br><span class="line">                        this_page &amp;= ~<span class="number">2</span>;</span><br><span class="line">                        *to_page_table = this_page;</span><br><span class="line">                        <span class="keyword">if</span> (this_page &gt; LOW_MEM) &#123;</span><br><span class="line">                                *from_page_table = this_page;</span><br><span class="line">                                this_page -= LOW_MEM;</span><br><span class="line">                                this_page &gt;&gt;= <span class="number">12</span>;</span><br><span class="line">                                mem_map[this_page]++;</span><br><span class="line">                        &#125;</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        invalidate();</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="34-进程-0-创建进程-1-时，为进程-1-建立了-task-struct-及内核栈，第一个页表，分别位于-16MB-物理内存的末尾倒数第一页、第二页。请问，这两个页究竟占用的是谁的线性地址空间，内核、进程-0、进程-1、还是没有占用任何线性地址空间？说明理由（可以图示）并给出代码证据。"><a href="#34-进程-0-创建进程-1-时，为进程-1-建立了-task-struct-及内核栈，第一个页表，分别位于-16MB-物理内存的末尾倒数第一页、第二页。请问，这两个页究竟占用的是谁的线性地址空间，内核、进程-0、进程-1、还是没有占用任何线性地址空间？说明理由（可以图示）并给出代码证据。" class="headerlink" title="34. 进程 0 创建进程 1 时，为进程 1 建立了 task_struct 及内核栈，第一个页表，分别位于 16MB 物理内存的末尾倒数第一页、第二页。请问，这两个页究竟占用的是谁的线性地址空间，内核、进程 0、进程 1、还是没有占用任何线性地址空间？说明理由（可以图示）并给出代码证据。"></a>34. 进程 0 创建进程 1 时，为进程 1 建立了 <code>task_struct</code> 及内核栈，第一个页表，分别位于 16MB 物理内存的末尾倒数第一页、第二页。请问，这两个页究竟占用的是谁的线性地址空间，内核、进程 0、进程 1、还是没有占用任何线性地址空间？说明理由（可以图示）并给出代码证据。</h3><p>均占用<strong>内核</strong>的线性地址空间。</p>
<p>需要分页内存时，内核通过调用 <code>get_free_page()</code> 获得空页。而正如前面（问题19）分析，<code>get_free_page()</code>通过逆向扫描页表位图，找到第一个空页后返回，因此得到的内存页位于 16M 内存末端。 代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 代码路径：mm/memory.c</span></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="title">get_free_page</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">register</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> __res <span class="title">asm</span><span class="params">(<span class="string">&quot;ax&quot;</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">__asm__(<span class="string">&quot;std ; repne ; scasb\\n\\t&quot;</span></span><br><span class="line">        <span class="string">&quot;jne 1f\\n\\t&quot;</span></span><br><span class="line">        <span class="string">&quot;movb $1,1(%%edi)\\n\\t&quot;</span></span><br><span class="line">        <span class="string">&quot;sall $12,%%ecx\\n\\t&quot;</span></span><br><span class="line">        <span class="string">&quot;addl %2,%%ecx\\n\\t&quot;</span></span><br><span class="line">        <span class="string">&quot;movl %%ecx,%%edx\\n\\t&quot;</span></span><br><span class="line">        <span class="string">&quot;movl $1024,%%ecx\\n\\t&quot;</span></span><br><span class="line">        <span class="string">&quot;leal 4092(%%edx),%%edi\\n\\t&quot;</span></span><br><span class="line">        <span class="string">&quot;rep ; stosl\\n\\t&quot;</span></span><br><span class="line">        <span class="string">&quot;movl %%edx,%%eax\\n&quot;</span></span><br><span class="line">        <span class="string">&quot;1:&quot;</span></span><br><span class="line">        :<span class="string">&quot;=a&quot;</span> (__res)</span><br><span class="line">        :<span class="string">&quot;0&quot;</span> (<span class="number">0</span>),<span class="string">&quot;i&quot;</span> (LOW_MEM),<span class="string">&quot;c&quot;</span> (PAGING_PAGES),</span><br><span class="line">        <span class="string">&quot;D&quot;</span> (mem_map+PAGING_PAGES<span class="number">-1</span>)</span><br><span class="line">        :<span class="string">&quot;di&quot;</span>,<span class="string">&quot;cx&quot;</span>,<span class="string">&quot;dx&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> __res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>进程 0 和进程 1 的 LDT 的限长属性将进程 0 和进程 1 的地址空间限定 0~640KB， 所以进程 0、 进程 1 均无法访问到这两个页面， 故两页面占用内核的线性地址空间。进程 0 的局部描述符如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 代码路径：boot/head.s</span></span><br><span class="line">.align <span class="number">2</span></span><br><span class="line">setup_paging:</span><br><span class="line">        movl $<span class="number">1024</span>*<span class="number">5</span>,%ecx               <span class="comment">/* 5 pages - pg_dir+4 page tables */</span></span><br><span class="line">        xorl %eax,%eax</span><br><span class="line">        xorl %edi,%edi                  <span class="comment">/* pg_dir is at 0x000 */</span></span><br><span class="line">        cld;rep;stosl</span><br><span class="line">        movl $pg0+<span class="number">7</span>,_pg_dir             <span class="comment">/* set present bit/user r/w */</span></span><br><span class="line">        movl $pg1+<span class="number">7</span>,_pg_dir+<span class="number">4</span>           <span class="comment">/*  --------- &quot; &quot; --------- */</span></span><br><span class="line">        movl $pg2+<span class="number">7</span>,_pg_dir+<span class="number">8</span>           <span class="comment">/*  --------- &quot; &quot; --------- */</span></span><br><span class="line">        movl $pg3+<span class="number">7</span>,_pg_dir+<span class="number">12</span>          <span class="comment">/*  --------- &quot; &quot; --------- */</span></span><br><span class="line">        movl $pg3+<span class="number">4092</span>,%edi</span><br><span class="line">        movl $<span class="number">0xfff007</span>,%eax             <span class="comment">/*  16Mb - 4096 + 7 (r/w user,p) */</span></span><br><span class="line">        <span class="built_in">std</span></span><br><span class="line"><span class="number">1</span>:      stosl                   <span class="comment">/* fill pages backwards - more efficient :-) */</span></span><br><span class="line">        subl $<span class="number">0x1000</span>,%eax</span><br><span class="line">        jge <span class="number">1b</span></span><br><span class="line">        xorl %eax,%eax          <span class="comment">/* pg_dir is at 0x0000 */</span></span><br><span class="line">        movl %eax,%cr3          <span class="comment">/* cr3 - page directory start */</span></span><br><span class="line">        movl %cr0,%eax</span><br><span class="line">        orl $<span class="number">0x80000000</span>,%eax</span><br><span class="line">        movl %eax,%cr0          <span class="comment">/* set paging (PG) bit */</span></span><br><span class="line">        ret                     <span class="comment">/* this also flushes prefetch-queue */</span></span><br></pre></td></tr></table></figure>
<p>上面的代码，指明了内核的线性地址空间为 <code>0x000000</code>~<code>0xffffff</code>（即前16M），且在内核的视角中，线性地址与物理地址一一对应。为进程1分配的这两个页，在16MB的顶端倒数第一页、第二页，因此占用内核的线性地址空间。 进程 0 的线性地址空间是内存前 640KB，因为进程 0 的 LDT 中的 limit 属性限制了进程 0 能够访问的地址空间。进程 1 拷贝了进程 0 的页表（160项），而这160个页表项即为内核第一个页表的前160项，指向的是物理内存前 640KB，因此无法访问到 16MB 的顶端倒数的两个页。 进程 0 创建进程 1 的时候，先后通过<code>get_free_page</code>函数从物理地址中取出了两个页，<strong>但是并没有将这两个页的物理地址填入任何新的页表项中。</strong>此时，只有内核的页表中包含了与这段物理地址对应的项，也就是说此时只有内核可以访问到这两个页，所以这两个页占用了内核线性空间。</p>
<blockquote>
<p>这里的进程 0 是指处在用户态的进程 0。而内核则是运行在所有进程中运行在 0 特权级的那部分。</p>
</blockquote>
<h3 id="35-内核和普通用户进程并不在一个线性地址空间内，为什么仍然能够访问普通用户进程的页面？"><a href="#35-内核和普通用户进程并不在一个线性地址空间内，为什么仍然能够访问普通用户进程的页面？" class="headerlink" title="35. 内核和普通用户进程并不在一个线性地址空间内，为什么仍然能够访问普通用户进程的页面？"></a>35. <strong>内核和普通用户进程并不在一个线性地址空间内，为什么仍然能够访问普通用户进程的页面？</strong></h3><p>内核的线性地址空间和用户进程不一样，内核是不能通过跨越线性地址访问进程的。但由于早就占有了所有的页面，而且特权级是 0，所以内核执行时，可以对所有的内容进行改动，“等价于”可以操作所有进程所在的页面。</p>
<p>内核在启动时便在所有内存上（16M）建立了恒等映射的页表，因此<strong>内核通过这套页表可以访问所有内存页面</strong>。而对于随后建立的用户进程，每个进程有独立的 LDT，其中记录了进程拥有的线性地址段的起始和限长，每个用户进程对应了不同的页表。<strong>用户进程只能通过自己的 LDT 访问自己的页表</strong>、进而访问物理内存。在合适地地址设置之下，用户进程便无法访问其它进程的地址空间。</p>
<h3 id="36-假设：经过一段时间的运行，操作系统中已经有5个进程在运行，且内核分别为进程-4、进程-5-分别创建了第一个页表，这两个页表在谁的线性地址空间？用图表示这两个页表在线性地址空间和物理地址空间的映射关系。"><a href="#36-假设：经过一段时间的运行，操作系统中已经有5个进程在运行，且内核分别为进程-4、进程-5-分别创建了第一个页表，这两个页表在谁的线性地址空间？用图表示这两个页表在线性地址空间和物理地址空间的映射关系。" class="headerlink" title="36. 假设：经过一段时间的运行，操作系统中已经有5个进程在运行，且内核分别为进程 4、进程 5 分别创建了第一个页表，这两个页表在谁的线性地址空间？用图表示这两个页表在线性地址空间和物理地址空间的映射关系。"></a>36. 假设：经过一段时间的运行，操作系统中已经有5个进程在运行，且内核分别为进程 4、进程 5 分别创建了第一个页表，这两个页表在谁的线性地址空间？用图表示这两个页表在线性地址空间和物理地址空间的映射关系。</h3><p>这两个页面均占用内核的线性地址空间。既然是内核线性地址空间，则与物理地址空间为一一对应关系。根据每一个进程占用 16 个页目录表项，则进程 4 占用从第 65～80 项的页目录表项。同理，进程 5 占用第 81～96 项的页目录表项。因为目前只分配了一个页面（用作进程的第一个页表），则分别只须要使用第一个页目录表项便可。又因为物理页是从后向前分配的，因此进程 5 的第一个页表其实在进程 4 的前面。映射关系如图：</p>
<div align="center">
<img src="/2022/12/31/Linux-0-11-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%E4%B8%8E%E6%80%9D%E8%80%83%E9%A2%98/linaddr_phyaddr_mapping.png" alt="线性地址及物理地址映射关系" style="zoom: 50%;"><br>
</div>


<h3 id="37-switch-to-代码中的-ljmp-0-n-t-很奇怪，按理说-jmp-指令跳转到得位置应该是一条指令的地址，可是这行代码却跳到了-quot-m-quot-amp-tmp-a-，这明明是一个数据的地址，更奇怪的，这行代码竟然能正确执行。请论述其中的道理。"><a href="#37-switch-to-代码中的-ljmp-0-n-t-很奇怪，按理说-jmp-指令跳转到得位置应该是一条指令的地址，可是这行代码却跳到了-quot-m-quot-amp-tmp-a-，这明明是一个数据的地址，更奇怪的，这行代码竟然能正确执行。请论述其中的道理。" class="headerlink" title="37. switch_to() 代码中的 ljmp %0\n\t 很奇怪，按理说 jmp 指令跳转到得位置应该是一条指令的地址，可是这行代码却跳到了 &quot;m&quot; (*&amp;__tmp.a)，这明明是一个数据的地址，更奇怪的，这行代码竟然能正确执行。请论述其中的道理。"></a>37. <code>switch_to()</code> 代码中的 <code>ljmp %0\n\t</code> 很奇怪，按理说 <code>jmp</code> 指令跳转到得位置应该是一条指令的地址，可是这行代码却跳到了 <code>&quot;m&quot; (*&amp;__tmp.a)</code>，这明明是一个数据的地址，更奇怪的，这行代码竟然能正确执行。请论述其中的道理。</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 代码路径：include/linux/sched.h</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> switch_to(n) &#123;\\</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span><span class="keyword">long</span> a,b;&#125; __tmp; \\</span><br><span class="line">__asm__(<span class="string">&quot;cmpl %%ecx,_current\\n\\t&quot;</span> \\</span><br><span class="line">        <span class="string">&quot;je 1f\\n\\t&quot;</span> \\</span><br><span class="line">        <span class="string">&quot;movw %%dx,%1\\n\\t&quot;</span> \\</span><br><span class="line">        <span class="string">&quot;xchgl %%ecx,_current\\n\\t&quot;</span> \\</span><br><span class="line">        <span class="string">&quot;ljmp %0\\n\\t&quot;</span> \\</span><br><span class="line">        <span class="string">&quot;cmpl %%ecx,_last_task_used_math\\n\\t&quot;</span> \\</span><br><span class="line">        <span class="string">&quot;jne 1f\\n\\t&quot;</span> \\</span><br><span class="line">        <span class="string">&quot;clts\\n&quot;</span> \\</span><br><span class="line">        <span class="string">&quot;1:&quot;</span> \\</span><br><span class="line">        ::<span class="string">&quot;m&quot;</span> (*&amp;__tmp.a),<span class="string">&quot;m&quot;</span> (*&amp;__tmp.b), \\</span><br><span class="line">        <span class="string">&quot;d&quot;</span> (_TSS(n)),<span class="string">&quot;c&quot;</span> ((<span class="keyword">long</span>) task[n])); \\</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个问题要由 Intel x86 体系结构来回答。80286及以后的x86系列处理器支持多任务，可以在硬件层面上完成任务切换。Intel x86 Manual 指出，可以通过1)跳转至任务门或者2)跳转至任务 TSS 对应的段选择子等方式来进行任务跳转。在这一过程中，由<strong>硬件</strong>负责保护现场、维护TSS、控制流跳转等工作。因此，<code>ljmp %0\\n\\t</code>实际上运用了 CPU 的多任务能力来完成任务切换，而不能简单地理解为跳转指令。</p>
<p><code>ljmp %0\\n\\t</code> 未使用任务门，而是通过第二种方式（跳转至指向 TSS 的段选择子）进行任务切换。在这一条指令中：</p>
<ol>
<li>CPU 自动将当前各个寄存器值保存在进程 0 的 TSS 中，</li>
<li>将进程1的 TSS 中的各项数据（包括通用寄存器、LDT 中保存的的代码段、数据段描述符等）恢复给 CPU 的各个寄存器，</li>
<li>将控制流转移给进程 1（移交给进程 1 的 <code>tss.eip</code>）。如果深究系统初始化过程，可以发现切换后 <code>%eip</code> 指向的就是 <code>main</code> 中 <code>inline fork</code> 中的 <code>if(__res &gt;= 0)</code> 语句。</li>
<li>并从0特权级的内核代码切换到3特权级。</li>
</ol>
<h3 id="38-根据代码详细分析，进程-0-是如何根据调度第一次切换到进程1的？"><a href="#38-根据代码详细分析，进程-0-是如何根据调度第一次切换到进程1的？" class="headerlink" title="38. 根据代码详细分析，进程 0 是如何根据调度第一次切换到进程1的？"></a>38. <strong>根据代码详细分析，进程 0 是如何根据调度第一次切换到进程1的？</strong></h3><p>进程 0 切换到进程 1，经历了两个过程：</p>
<ol>
<li>进程 0 通过 <code>fork</code> 函数创建进程 1，并使其处在就绪态。</li>
<li>进程 0 调用 <code>pause</code> 函数。<code>pause</code> 函数通过 <code>int 0x80</code> 中断跳转到 <code>sys_pause</code> 函数，将进程 0 自身设为可中断等待状态 (<code>TASK_INTERRUPTIBLE</code>)，然后调用 <code>schedule</code> 函数进行进程调度。<code>schedule</code> 函数遍历所有进程，比较进程的运行状态和剩余时间片，找出处于就绪态且剩余时间片最多（即 <code>counter</code> 最大）的进程。此时操作系统上只有进程 0 和进程 1，且进程 0 是挂起状态（可中断等待状态），只有进程 1 是就绪态，于是切换到进程 1 执行。</li>
<li>最终在 <code>schedule</code> 函数中调用 <code>switch_to(1)</code>（见问题 37 ——前一个问题]），通过 x86 芯片提供的任务切换接口切换到进程 1。</li>
</ol>
<p>参考代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 代码路径：init/main.c</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">        ......</span><br><span class="line">        sti();</span><br><span class="line">        move_to_user_mode();</span><br><span class="line">        <span class="keyword">if</span> (!fork()) &#123;	<span class="comment">// 1. task 0 create task 1</span></span><br><span class="line">                init();</span><br><span class="line">        &#125;</span><br><span class="line">        ......</span><br><span class="line">        <span class="keyword">for</span>(;;) pause(); <span class="comment">// 2. task 0 call pause()</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 代码路径：include/unistd.h</span></span><br><span class="line">......</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_pause	29</span></span><br><span class="line">......</span><br><span class="line"></span><br><span class="line"><span class="comment">// pause() -&gt; int 0x80</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _syscall0(type,name) \\</span></span><br><span class="line">type pause(void) \\</span><br><span class="line">&#123; \\</span><br><span class="line"><span class="keyword">long</span> __res; \\</span><br><span class="line"><span class="function">__asm__ <span class="title">volatile</span> <span class="params">(<span class="string">&quot;int $0x80&quot;</span> \\</span></span></span><br><span class="line"><span class="function"><span class="params">        : <span class="string">&quot;=a&quot;</span> (__res) \\</span></span></span><br><span class="line"><span class="function"><span class="params">        : <span class="string">&quot;0&quot;</span> (__NR_##name))</span></span>; \\</span><br><span class="line"><span class="keyword">if</span> (__res &gt;= <span class="number">0</span>) \\</span><br><span class="line">        <span class="keyword">return</span> (type) __res; \\</span><br><span class="line">errno = -__res; \\</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>; \\</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 代码路径：kernel/system_call.s</span></span><br><span class="line">_system_call:</span><br><span class="line">        ...... <span class="comment">// instructions that push registers into stack</span></span><br><span class="line">        call _sys_call_table(,%eax,<span class="number">4</span>) <span class="comment">// int 0x80 -&gt; sys_call_table</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 代码路径：include/linux/sys.h</span></span><br><span class="line"><span class="comment">// sys_call_table -&gt; sys_pause</span></span><br><span class="line">fn_ptr sys_call_table[] = &#123;</span><br><span class="line">	    ......</span><br><span class="line">	    sys_pause, <span class="comment">// element with index 29</span></span><br><span class="line">	    ......</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 代码路径：kernel/sched.c</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sys_pause</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="comment">// 将进程0设置为可中断等待状态，如果产生某种中断，或其他进程给这个进程发送特定信号，</span></span><br><span class="line">        <span class="comment">// 才有可能将这个进程重新唤醒（即设为就绪态）</span></span><br><span class="line">        current-&gt;state = TASK_INTERRUPTIBLE;</span><br><span class="line">        schedule(); <span class="comment">// sys_pause -&gt; schedule</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">......</span><br><span class="line"></span><br><span class="line"><span class="comment">// schedule -&gt; task 1</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">schedule</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        ...... <span class="comment">// variable delaration; signal and alarm handling</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">                c = <span class="number">-1</span>;</span><br><span class="line">                next = <span class="number">0</span>;</span><br><span class="line">                i = NR_TASKS;</span><br><span class="line">                p = &amp;task[NR_TASKS];</span><br><span class="line">                <span class="keyword">while</span> (--i) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (!*--p)</span><br><span class="line">                                <span class="keyword">continue</span>;</span><br><span class="line">                        <span class="keyword">if</span> ((*p)-&gt;state == TASK_RUNNING &amp;&amp; (*p)-&gt;counter &gt; c)</span><br><span class="line">                                c = (*p)-&gt;counter, next = i;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (c) <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">for</span>(p = &amp;LAST_TASK ; p &gt; &amp;FIRST_TASK ; --p)</span><br><span class="line">                        <span class="keyword">if</span> (*p)</span><br><span class="line">                                (*p)-&gt;counter = ((*p)-&gt;counter &gt;&gt; <span class="number">1</span>) +</span><br><span class="line">                                                (*p)-&gt;priority;</span><br><span class="line">        &#125;</span><br><span class="line">        switch_to(next); <span class="comment">// finally switch to task 1 by jumping to its tss</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="39-进程-0-进行简单初始化后，通过调用-fork-创建进程-1。跟踪代码时我们发现，fork代码执行了两次，第一次，执行-fork-代码后，跳过-init-直接执行了-for-pause-，第二次执行-fork-代码后，执行了-init-。奇怪的是，我们在代码中并没有看到向转向-fork-的-goto-语句，也没有看到循环语句，是什么原因导致-fork-反复执行？请说明理由（可以图示），并给出代码证据。"><a href="#39-进程-0-进行简单初始化后，通过调用-fork-创建进程-1。跟踪代码时我们发现，fork代码执行了两次，第一次，执行-fork-代码后，跳过-init-直接执行了-for-pause-，第二次执行-fork-代码后，执行了-init-。奇怪的是，我们在代码中并没有看到向转向-fork-的-goto-语句，也没有看到循环语句，是什么原因导致-fork-反复执行？请说明理由（可以图示），并给出代码证据。" class="headerlink" title="39. 进程 0 进行简单初始化后，通过调用 fork() 创建进程 1。跟踪代码时我们发现，fork代码执行了两次，第一次，执行 fork 代码后，跳过 init() 直接执行了 for(;;) pause();，第二次执行 fork 代码后，执行了 init()。奇怪的是，我们在代码中并没有看到向转向 fork 的 goto 语句，也没有看到循环语句，是什么原因导致 fork 反复执行？请说明理由（可以图示），并给出代码证据。"></a>39. 进程 0 进行简单初始化后，通过调用 <code>fork()</code> 创建进程 1。跟踪代码时我们发现，<code>fork</code>代码执行了两次，第一次，执行 <code>fork</code> 代码后，跳过 <code>init()</code> 直接执行了 <code>for(;;) pause();</code>，第二次执行 <code>fork</code> 代码后，执行了 <code>init()</code>。奇怪的是，我们在代码中并没有看到向转向 <code>fork</code> 的 <code>goto</code> 语句，也没有看到循环语句，是什么原因导致 <code>fork</code> 反复执行？请说明理由（可以图示），并给出代码证据。</h3><p>在 Unix 标准中，<code>fork()</code> 是唯一一个<strong>调用一次、返回两次</strong>的函数。这是由其函数功能决定的：<code>fork</code> 创建了一个与父进程一模一样的新进程，因此在两个进程中势必都会返回一次。为了区分父子进程，<code>fork</code> 在父进程返回子进程的 <code>pid</code>，在子进程返回 <code>0</code>。通过调度后两个进程都会从 <code>fork</code> 处继续执行，随后便根据不同的返回值在 <code>if</code> 处走向了不同的分支。</p>
<p>然而作为一门操作系统课程，仅在用户角度分析 <code>fork</code> 是不够的。下面试从<strong>操作系统代码的角度做具体分析</strong>。</p>
<p><code>main.c</code> 中的 <code>fork</code> 为特别处理的 <code>inline</code> 函数，其中调用了 <code>int 0x80</code> 产生系统中断，并最终跳转至内核中的<code>copy_process</code>函数。系统中断时，CPU 自动将 <code>%ss, %esp, %eflags, %cs, %eip</code> 压栈，其中 <code>%eip</code> 为 <code>int 0x80</code> 的下一指令的地址。在 <code>copy_process</code> 中，内核将进程 0 的 TSS 复制得到进程 1 的 TSS，并将进程 1 的  <code>tss.eax</code> 手动设为 <code>0</code>，而将进程 1 的<code>pid</code>（<code>last_pid</code>）返回给进程 0。在进程调度时 TSS 中的值被恢复至相应寄存器中，包括 <code>%eip</code>， <code>%eax</code> 等。所以中断返回后，进程 0 和进程 1 均会从 <code>int  0x80</code> 的下一句开始执行，即 <code>fork</code> 返回了两次。</p>
<p>由于 <code>%eax</code> 代表返回值，所以进程 0 和进程 1 会得到不同的返回值，在 <code>fork</code> 返回到进程0后，进程 0 判断返回值非 0，因此执行代码 <code>for(;;) pause();</code></p>
<p>在 <code>sys_pause</code> 函数中，内核设置了进程0的状态为 <code>TASK_INTERRUPTIBLE</code>，并进行进程调度。由于只有进程1处于就绪态，因此调度执行进程 1 的指令。由于进程 1 在 TSS 中设置了 <code>%eip</code> 等寄存器的值，因此从 <code>int 0x80</code> 的下一条指令开始执行，且设定返回 <code>%eax</code> 的值作为 <code>fork</code> 的返回值（值为 0），因此进程1执行了 <code>init()</code> 所在的分支。</p>
<p>参考代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 代码路径：init/main.c</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span>	</span>&#123;</span><br><span class="line">        <span class="comment">// 一些基本的初始化，其中很多需要0特权级</span></span><br><span class="line">        ......</span><br><span class="line">        move_to_user_mode();</span><br><span class="line">        <span class="keyword">if</span> (!fork()) &#123;          <span class="comment">/* we count on this going ok */</span></span><br><span class="line">                init();</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过宏展开的fork</span></span><br><span class="line"><span class="comment">// 代码路径：init/main.c </span></span><br><span class="line"><span class="comment">// 展开前为：static inline _syscall0(int,fork)</span></span><br><span class="line"><span class="comment">// 宏(_syscall0)定义路径：include/unistd.c</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">fork</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">long</span> __res; </span><br><span class="line"><span class="function">__asm__ <span class="title">volatile</span> <span class="params">(<span class="string">&quot;int $0x80&quot;</span> \\</span></span></span><br><span class="line"><span class="function"><span class="params">        : <span class="string">&quot;=a&quot;</span> (__res) \\ <span class="comment">//%eax的值输出至__res。%eax是copy_process()的返回值last_pid(=1)</span></span></span></span><br><span class="line"><span class="function"><span class="params">        : <span class="string">&quot;0&quot;</span> (__NR_##name))</span></span>; \\</span><br><span class="line"><span class="keyword">if</span> (__res &gt;= <span class="number">0</span>) \\        <span class="comment">//iret后，执行这一行</span></span><br><span class="line">        <span class="keyword">return</span> (type) __res; \\ <span class="comment">//返回1！</span></span><br><span class="line">errno = -__res; \\</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>; \\</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 代码路径：kernel/fork.c</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">copy_process</span><span class="params">(<span class="keyword">int</span> nr,<span class="keyword">long</span> ebp,<span class="keyword">long</span> edi,<span class="keyword">long</span> esi,<span class="keyword">long</span> gs,<span class="keyword">long</span> none,</span></span></span><br><span class="line"><span class="function"><span class="params">                <span class="keyword">long</span> ebx,<span class="keyword">long</span> ecx,<span class="keyword">long</span> edx,</span></span></span><br><span class="line"><span class="function"><span class="params">                <span class="keyword">long</span> fs,<span class="keyword">long</span> es,<span class="keyword">long</span> ds,</span></span></span><br><span class="line"><span class="function"><span class="params">                <span class="keyword">long</span> eip,<span class="keyword">long</span> cs,<span class="keyword">long</span> eflags,<span class="keyword">long</span> esp,<span class="keyword">long</span> ss)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">p</span>;</span></span><br><span class="line">        <span class="keyword">int</span> i;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">file</span> *<span class="title">f</span>;</span></span><br><span class="line"></span><br><span class="line">        p = (struct task_struct *) get_free_page();</span><br><span class="line">        <span class="keyword">if</span> (!p)</span><br><span class="line">                <span class="keyword">return</span> -EAGAIN;</span><br><span class="line">        task[nr] = p;</span><br><span class="line">        *p = *current;  <span class="comment">/* NOTE! this doesn&#x27;t copy the supervisor stack */</span></span><br><span class="line">        p-&gt;state = TASK_UNINTERRUPTIBLE;</span><br><span class="line">        p-&gt;pid = last_pid;</span><br><span class="line">        p-&gt;father = current-&gt;pid;</span><br><span class="line">        p-&gt;counter = p-&gt;priority;</span><br><span class="line">		...... <span class="comment">// 略去一些不相关的元素的copy</span></span><br><span class="line">        p-&gt;tss.esp0 = PAGE_SIZE + (<span class="keyword">long</span>) p;</span><br><span class="line">        p-&gt;tss.ss0 = <span class="number">0x10</span>;</span><br><span class="line">        p-&gt;tss.eip = eip;</span><br><span class="line">        p-&gt;tss.eflags = eflags;</span><br><span class="line">        p-&gt;tss.eax = <span class="number">0</span>;</span><br><span class="line">        p-&gt;tss.ecx = ecx;</span><br><span class="line">        p-&gt;tss.edx = edx;</span><br><span class="line">        ...... <span class="comment">// copy其它通用寄存器</span></span><br><span class="line">        p-&gt;tss.es = es &amp; <span class="number">0xffff</span>;</span><br><span class="line">        p-&gt;tss.cs = cs &amp; <span class="number">0xffff</span>;</span><br><span class="line">        ...... <span class="comment">// copy其它段寄存器(ss,ds,fs,gs)</span></span><br><span class="line">        p-&gt;tss.ldt = _LDT(nr);</span><br><span class="line">        p-&gt;tss.trace_bitmap = <span class="number">0x80000000</span>;</span><br><span class="line">        <span class="keyword">if</span> (last_task_used_math == current)</span><br><span class="line">                __asm__(<span class="string">&quot;clts ; fnsave %0&quot;</span>::<span class="string">&quot;m&quot;</span> (p-&gt;tss.i387));</span><br><span class="line">        <span class="keyword">if</span> (copy_mem(nr,p)) &#123;</span><br><span class="line">                task[nr] = <span class="literal">NULL</span>;</span><br><span class="line">                free_page((<span class="keyword">long</span>) p);</span><br><span class="line">                <span class="keyword">return</span> -EAGAIN;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;NR_OPEN;i++)</span><br><span class="line">                <span class="keyword">if</span> (f=p-&gt;filp[i])</span><br><span class="line">                        f-&gt;f_count++;</span><br><span class="line">        ...... <span class="comment">// 略去一些不重要的内容</span></span><br><span class="line">        set_tss_desc(gdt+(nr&lt;&lt;<span class="number">1</span>)+FIRST_TSS_ENTRY,&amp;(p-&gt;tss));</span><br><span class="line">        set_ldt_desc(gdt+(nr&lt;&lt;<span class="number">1</span>)+FIRST_LDT_ENTRY,&amp;(p-&gt;ldt));</span><br><span class="line">        p-&gt;state = TASK_RUNNING;        <span class="comment">/* do this last, just in case */</span></span><br><span class="line">        <span class="keyword">return</span> last_pid;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="40-详细分析进程调度的全过程。考虑所有可能（signal、alarm除外）"><a href="#40-详细分析进程调度的全过程。考虑所有可能（signal、alarm除外）" class="headerlink" title="40. 详细分析进程调度的全过程。考虑所有可能（signal、alarm除外）"></a>40. 详细分析进程调度的全过程。考虑所有可能（signal、alarm除外）</h3><p><strong>Case I 有就绪进程，且时间片没有用完</strong></p>
<p>正常情况下，<code>schedule()</code> 函数首先扫描任务数组。通过比较每个就绪任务（即处于 <code>TASK_RUNNING</code> 状态的进程）的剩余时间片数（即运行时间滴答计数 <code>counter</code>） 来确定哪个进程运行的时间最少。哪一个进程的值大，就表示运行时间还不长，于是选中该进程，调用 <code>switch_to()</code> 执行实际的进程切换操作</p>
<p><strong>Case II 有就绪进程，但所有就绪进程的时间片都已用完</strong>（对应 <code>schedule()</code> 中 <code>c==0</code> 分支）</p>
<p>若此时所有就绪进程的时间片都已经用完，系统就会根据每个进程的优先权值 <code>priority</code> ，对所有进程（包括正在睡眠的进程）重新分配时间片。计算公式为：</p>
<script type="math/tex; mode=display">
\mathtt{counter}=\mathtt{counter}/2+\mathtt{priority}\notag</script><p>对时间片已经用完的就绪进程，计算后会得到数值等于 <code>priority</code> 的时间片；对睡眠进程，剩余时间片会增加，剩余时间片数最终会收敛至 <code>priority</code> 的2倍。</p>
<p>然后 <code>schdeule()</code> 函数重新扫描任务数组中所有处于 <code>TASK_RUNNING</code> 状态的进程，重复上述过程，直到选择出一个进程为止，最后调用 <code>switch_to()</code> 执行实际的进程切换操作。</p>
<p><strong>Case III 无就绪进程</strong>（ 退出循环后<code>next==0, c==-1</code> ）</p>
<p>对操作系统来说这种情况看起来有些奇怪。但事实上是很有可能发生的。例如你运行了一个应用程序，但它正在控制台等待你的输入（例如正在运行 <code>scanf</code> 语句）而被挂起。</p>
<p>此时 <code>schedule()</code> 函数中的 <code>c==-1，next==0</code>，跳出循环后，执行 <code>switch_to(0)</code>，即切换到进程 0 继续执行，<strong>即使此时进程 0 处于挂起状态</strong>。总之所有进程都不就绪时系统会执行进程 0 陷入空循环，而不是调用芯片的 <code>nop</code>指令。因此，进程 0 在有些操作系统上又被称为 「System Idle Process」。</p>
<p>参考代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 代码路径：kernel/sched.c	</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *  &#x27;schedule()&#x27; is the scheduler function. This is GOOD CODE! There</span></span><br><span class="line"><span class="comment"> * probably won&#x27;t be any reason to change this, as it should work well</span></span><br><span class="line"><span class="comment"> * in all circumstances (ie gives IO-bound processes good response etc).</span></span><br><span class="line"><span class="comment"> * The one thing you might take a look at is the signal-handler code here.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *   NOTE!!  Task 0 is the &#x27;idle&#x27; task, which gets called when no other</span></span><br><span class="line"><span class="comment"> * tasks can run. It can not be killed, and it cannot sleep. The &#x27;state&#x27;</span></span><br><span class="line"><span class="comment"> * information in task[0] is never used.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">schedule</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i,next,c;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> ** <span class="title">p</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* check alarm, wake up any interruptible tasks that have got a signal */</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(p = &amp;LAST_TASK ; p &gt; &amp;FIRST_TASK ; --p)</span><br><span class="line">                <span class="keyword">if</span> (*p) &#123;</span><br><span class="line">                        <span class="keyword">if</span> ((*p)-&gt;alarm &amp;&amp; (*p)-&gt;alarm &lt; jiffies) &#123;</span><br><span class="line">                                        (*p)-&gt;signal |= (<span class="number">1</span>&lt;&lt;(SIGALRM<span class="number">-1</span>));</span><br><span class="line">                                        (*p)-&gt;alarm = <span class="number">0</span>;</span><br><span class="line">                                &#125;</span><br><span class="line">                        <span class="keyword">if</span> (((*p)-&gt;signal &amp; ~(_BLOCKABLE &amp; (*p)-&gt;blocked)) &amp;&amp;</span><br><span class="line">                        (*p)-&gt;state==TASK_INTERRUPTIBLE)</span><br><span class="line">                                (*p)-&gt;state=TASK_RUNNING;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* this is the scheduler proper: */</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">                c = <span class="number">-1</span>;</span><br><span class="line">                next = <span class="number">0</span>;</span><br><span class="line">                i = NR_TASKS;</span><br><span class="line">                p = &amp;task[NR_TASKS];</span><br><span class="line">                <span class="keyword">while</span> (--i) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (!*--p)</span><br><span class="line">                                <span class="keyword">continue</span>;</span><br><span class="line">                        <span class="keyword">if</span> ((*p)-&gt;state == TASK_RUNNING &amp;&amp; (*p)-&gt;counter &gt; c)</span><br><span class="line">                                c = (*p)-&gt;counter, next = i;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (c) <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">for</span>(p = &amp;LAST_TASK ; p &gt; &amp;FIRST_TASK ; --p)</span><br><span class="line">                        <span class="keyword">if</span> (*p)</span><br><span class="line">                                (*p)-&gt;counter = ((*p)-&gt;counter &gt;&gt; <span class="number">1</span>) +</span><br><span class="line">                                                (*p)-&gt;priority;</span><br><span class="line">        &#125;</span><br><span class="line">        switch_to(next); <span class="comment">// switch_to源码及代码分析见问题23</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 代码路径：init/main.c</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span>	</span>&#123;</span><br><span class="line">        <span class="comment">// 一些基本的初始化，其中很多需要0特权级</span></span><br><span class="line">        ......</span><br><span class="line">        move_to_user_mode();</span><br><span class="line">        <span class="keyword">if</span> (!fork()) &#123;          <span class="comment">/* we count on this going ok */</span></span><br><span class="line">        <span class="comment">// 进程 1 所在分支</span></span><br><span class="line">                init();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 进程 0 中的空循环，在系统无就绪进程时调度运行</span></span><br><span class="line">        <span class="keyword">for</span>(;;) pause();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="41-详细分析一个进程从创建、加载程序、执行、退出的全过程。"><a href="#41-详细分析一个进程从创建、加载程序、执行、退出的全过程。" class="headerlink" title="41. 详细分析一个进程从创建、加载程序、执行、退出的全过程。"></a>41. <strong>详细分析一个进程从创建、加载程序、执行、退出的全过程。</strong></h3><ol>
<li><p><strong>创建进程，调用fork函数。</strong>（详见 <code>copy_process</code> 函数）</p>
<p>a) 准备阶段，为进程在 <code>task[64]</code> 找到空闲位置，即 <code>find_empty_process()</code>；</p>
<p>b) 为进程管理结构找到储存空间：task_struct和内核栈。</p>
<p>c) 父进程为子进程复制 <code>task_struct</code> 结构</p>
<p>d) 为新进程复制页表及其其对应的页目录项（但不复制页表指向的内存页）</p>
<p>e) 为新进程设置新的段，并设置 LDT</p>
<p>f) 在新旧进程之间共享打开的文件</p>
<p>g) 将新进程的 TSS 和 LDT 挂载到全局描述符表 GDT 上</p>
<p>h) 将新进程设为就绪态</p>
</li>
<li><p><strong>加载进程</strong>（对应 <code>execve</code> 函数）</p>
<p>a) 检查参数和外部环境变量和可执行文件</p>
<p>b) 释放进程的页表</p>
<p>c) 重新设置进程的程序代码段和数据段</p>
<p>d) 调整进程的 <code>task_struct</code></p>
</li>
<li><p><strong>进程运行</strong>（运行新程序遭到缺页中断）</p>
<p>a) 进程的代码实际未被加载到内存中；试图执行代码时产生缺页中断并由操作系统响应</p>
<blockquote>
<p>严格来说是经过编译后的机器码，不是代码</p>
</blockquote>
<p>b) 为进程申请一个物理内存页</p>
<p>c) 将程序代码加载到新分配的页面中</p>
<p>d) 将物理内存地址与线性地址空间对应起来</p>
<p>e) 不断通过缺页中断加载进程的全部内容</p>
<p>f) 运行时如果进程内存不足继续产生缺页中断，往复执行这一过程</p>
</li>
<li><p><strong>进程退出</strong></p>
<p>a) 进程先处理退出事务</p>
<p>b) 释放进程所占页面</p>
<p>c) 解除进程与文件有关的内容并给父进程发信号</p>
<p>d) 进程退出后执行进程调度</p>
</li>
</ol>
<h3 id="42-详细分析多个进程（无父子关系）共享一个可执行程序的完整过程。"><a href="#42-详细分析多个进程（无父子关系）共享一个可执行程序的完整过程。" class="headerlink" title="42. 详细分析多个进程（无父子关系）共享一个可执行程序的完整过程。"></a>42. <strong>详细分析多个进程（无父子关系）共享一个可执行程序的完整过程。</strong></h3><p>为了便于分析，我们假设：</p>
<ol>
<li><p>三个进程是通过 <code>fork+execve</code> 的经典方式执行的 </p>
</li>
<li><p>三个进程执行间隔很短——例如，通过 <code>bash</code> 脚本执行同一可执行文件的多个副本。</p>
</li>
<li><p>程序执行的速度远大于外存读取的速度，且基本是顺序执行，不会在一小段代码中反复循环。</p>
</li>
<li><p>开机后该执行程序还没有执行过，在缓冲区中没有缓存。</p>
</li>
</ol>
<h4 id="㈠-execve-加载程序头部"><a href="#㈠-execve-加载程序头部" class="headerlink" title="㈠ execve 加载程序头部"></a>㈠ <code>execve</code> 加载程序头部</h4><p>假设有三个进程 A、B、C，进程 A 先执行，之后是 B 最后是 C，它们没有父子关系。A 进程启动时会调用 <code>execve</code> 函数打开新的可执行文件，然后调用 <code>bread_page()</code> 函数读取文件开头的内容。<code>bread_page</code> 函数会分配缓冲块，进行设备到缓冲块的数据读取。因为此时为设备读入，时间较长，所以会给该缓冲块加锁，调用 <code>sleep_on</code> 函数，A进程被挂起，调用 <code>schedule()</code>， B 进程开始执行。</p>
<p>B进程也首先执行 <code>execve()</code> 函数。B 进程调用 <code>execve</code> 函数，同样会调用 <code>bread_page()</code>，由于此时内核检测到 B 进程需要读的数据已经进入缓冲区中，则直接返回。但是由于此时设备读没有完成，缓冲块已被加锁，所以 B 将因为等待而被系统挂起，之后调用 <code>schedule()</code> 函数。</p>
<p>C 进程开始执行，但是同 B 一样，被系统挂起，调用 <code>schedule()</code> 函数，假设此时无其它进程，则系统进程 0 开始执行。</p>
<p>等到读操作完成，外设产生中断，中断服务程序开始工作。它给读取的文件缓冲区解锁并调用 <code>wake_up()</code> 函数，传递的参数是 <code>&amp;bh-&gt;b_wait</code>，该函数首先将 C 唤醒，此后中断服务程序结束，开始进程调度。此时 C 就绪，C 程序开始执行，并将 B 进程设为就绪态。C 执行结束或者 C 的时间片削减为 0 （严格来说， C 中调用到 <code>schedule()</code> 也会导致进程切换——但我们先忽略这种情况） 时，切换到 B 进程执行。进程 B 也在 <code>sleep_on()</code> 函数中，调用 <code>schedule</code> 函数进程进程切换后，B 最先回到 <code>sleep_on</code> 函数，进程 B 开始执行，并将进程 A 设为就绪态。同理当 B 执行完或者时间片削减为 0 时，切换到进程 A 执行。此时 A 的内核栈中 <code>sleep_on().tmp</code> 对应 <code>NULL</code>，不会再唤醒进程了。</p>
<h4 id="㈡-缺页中断加载随后的程序片段"><a href="#㈡-缺页中断加载随后的程序片段" class="headerlink" title="㈡ 缺页中断加载随后的程序片段"></a>㈡ <strong>缺页中断加载随后的程序片段</strong></h4><p>可执行程序的最开头部分由 <code>do_execve</code> 调用 <code>bread_page</code> 读入内存，但其它的部分则不会立马读入内存，而是被运行到时才读取。这种 lazy loading 机制（在源码注释中称为“demand-loading”）让程序只在真正运行到时才被加载进入内存，提高了操作系统创建进程的效率。此时，触发文件加载的不再是 <code>execve</code>，而是缺页中断。</p>
<blockquote>
<p>严格来说内存页遇到问题产生的中断不是“缺页中断”，而是“页故障”（page fault），后者才是 Intel 体系结构中的名称。前面</p>
</blockquote>
<p>假设进程 C 被唤醒之后一路高歌猛进，在进程切换前直接执行到了未被加载的页。此时处理器触发页故障软中断，调用页故障处理程序。页故障处理程序根据页故障的 error code 判断是缺页故障（见 <code>mm/page.s</code>），跳转到 <code>do_no_page</code> 函数执行。<code>do_no_page</code> 函数首先根据缺失页的线性地址计算出需要读取的设备块编号，然后调用 <code>bread_page</code> 读取至空闲的物理页，最后调用 <code>put_page</code> 将物理页映射到 C 的线性地址空间。</p>
<p>在 <code>bread_page</code> 的过程中又会进入 <code>sleep_on</code>，轮到进程 B 执行。很快，进程 B 也遇到了同样问题（缺页），同样来到 <code>do_no_page</code> 执行类似的逻辑。此时若 C 中请求的页已经读取完毕，<code>do_no_page</code> 会共享相同的页，直接返回继续执行。若此时 C 请求的页尚未读取完毕，则进程 B 的缺页中断处理程序仍会调用 <code>bread_page</code> ，请求相同的页，调用 <code>sleep_on()</code> 挂起运行。最后，进程 A 的情况与进程 B 是类似的。</p>
<p>由此可见，进程 A、B、C 会在“运行、缺页中断、运行、缺页中断……”的循环中轮流执行。</p>
<p><strong>最后要强调的是，</strong>依次创建的 3 个用户进程，每个进程都有自己的 <code>task</code> 数组项。三个进程虽然共享程序数据，但栈和数据相互独立。操作系统使用不同的 TSS 和 LDT 实现对进程的保护，不同的进程无法相互访问对方的地址空间。</p>
<h3 id="43-打开保护模式和分页后，逻辑地址到物理地址是如何转换的？"><a href="#43-打开保护模式和分页后，逻辑地址到物理地址是如何转换的？" class="headerlink" title="43. 打开保护模式和分页后，逻辑地址到物理地址是如何转换的？"></a>43. 打开保护模式和分页后，逻辑地址到物理地址是如何转换的？</h3><p>打开保护模式后，x86 处理器开始按段寻址，先按段寄存器中的值选择一个段，然后将逻辑地址加上段基址形成线性地址。若不打开分页，此时的线性地址就是物理地址，处理器会直接根据线性地址到内存中寻址。</p>
<div align="center">
<img src="/2022/12/31/Linux-0-11-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%E4%B8%8E%E6%80%9D%E8%80%83%E9%A2%98/seg_addressing.png" alt="逻辑地址与线性地址的转换关系[4]" style="zoom:50%;"><br>
</div>

<p>打开分页后，线性地址需要进一步经过页表的转换才会变换为物理地址。分页机制在线性地址和物理地址之间增加一层新的 indirection，线性地址又成为了“虚拟地址”。</p>
<p>保护模式下，每个线性地址为 32 位，MMU 按照 10-10-12 的长度来识别线性地址的值。<code>%cr3</code> 中存储着页目录表的基址，线性地址的前 10 位指向页目录表中的页目录项，由此得到对应的页表地址。中间 10 位记录了页表中的页表项位置，由此得到页的位置，最后 12 位表示页内偏移。</p>
<div align="center">
<img src="/2022/12/31/Linux-0-11-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%E4%B8%8E%E6%80%9D%E8%80%83%E9%A2%98/page_addressing.jpeg" alt="线性地址与物理地址的转换关系——开启分页后[2]"><br>
</div>

<p>同时开启分段（即保护模式）和分页后，完整的地址转换如下图所示：</p>
<div align="center">
<img src="/2022/12/31/Linux-0-11-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%E4%B8%8E%E6%80%9D%E8%80%83%E9%A2%98/seg_and_paging_addressing.png" alt="完整的段页模式地址转换示意图[4]"><br>
</div>



<h2 id="Part-III-高速缓冲区"><a href="#Part-III-高速缓冲区" class="headerlink" title="Part III 高速缓冲区"></a>Part III 高速缓冲区</h2><h3 id="44-为什么要设计缓冲区，有什么好处？"><a href="#44-为什么要设计缓冲区，有什么好处？" class="headerlink" title="44. 为什么要设计缓冲区，有什么好处？"></a>44. <strong>为什么要设计缓冲区，有什么好处？</strong></h3><p>设计缓冲区的核心思想在于<strong>局部性原理：如果一段代码或数据在最近被使用过，那它在随后就很有可能被再次使用。</strong></p>
<p>在计算机中，内存间的读取速度比外部存储设备（e.g. 硬盘）的读取速度快 2~3 个数量级。如果某个进程将硬盘数据读到缓冲区之后，其他进程刚好也需要读取这些数据，那么就可以直接从缓冲区中读取，大大加快读取速度。如果某个进程将新数据写到缓冲区之后，其他进程刚好也需要修改这些数据，那么就可以直接在缓冲区中修改，避免多次写入硬盘。直接从缓冲区读写的数据越多，计算机的整体性能就会越高。</p>
<p>此外，缓冲区页构成所有块设备数据的统一集散地，使操作系统的设计更方便，更灵活。</p>
<h3 id="45-getblk-函数中，申请空闲缓冲块的标准就是-b-count-为-0，而申请到之后，为什么在-wait-on-buffer-bh-后又执行if-bh-gt-b-count-来判断-b-count-是否为0-？"><a href="#45-getblk-函数中，申请空闲缓冲块的标准就是-b-count-为-0，而申请到之后，为什么在-wait-on-buffer-bh-后又执行if-bh-gt-b-count-来判断-b-count-是否为0-？" class="headerlink" title="45. getblk 函数中，申请空闲缓冲块的标准就是 b_count 为 0，而申请到之后，为什么在 wait_on_buffer(bh) 后又执行if(bh-&gt;b_count) 来判断 b_count 是否为0 ？"></a>45. <code>getblk</code> 函数中，申请空闲缓冲块的标准就是 <code>b_count</code> 为 <code>0</code>，而申请到之后，为什么在 <code>wait_on_buffer(bh)</code> 后又执行<code>if(bh-&gt;b_count)</code> 来判断 <code>b_count</code> 是否为<code>0</code> ？</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 代码路径：fs\\buffer.c</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BADNESS(bh) (((bh)-&gt;b_dirt<span class="meta-string">&lt;&lt;1)+(bh)-&gt;</span>b_lock)</span></span><br><span class="line"><span class="function">struct buffer_head * <span class="title">getblk</span><span class="params">(<span class="keyword">int</span> dev,<span class="keyword">int</span> block)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">repeat:</span><br><span class="line">        <span class="keyword">if</span> (bh = get_hash_table(dev,block))</span><br><span class="line">                <span class="keyword">return</span> bh;</span><br><span class="line">        ......</span><br><span class="line">        wait_on_buffer(bh);</span><br><span class="line">        <span class="keyword">if</span> (bh-&gt;b_count)</span><br><span class="line">                <span class="keyword">goto</span> repeat;</span><br><span class="line">        ......</span><br><span class="line">        <span class="keyword">return</span> bh;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>wait_on_buffer(bh)</code> 内包含睡眠函数，在睡眠中可能已有其它进程执行过。睡眠唤醒后，之前找到的比较合适的空闲缓冲块<strong>可能在睡眠阶段又被其他任务所占用</strong>，因此必须重新判断是否被修改。若判断被占用则回到 <code>repeat</code>，重新获取资源。</p>
<p>字段 <code>b_count</code> 用于标记「每个缓冲块有多少个进程在共享」。只有当<code>b_count==0</code> 时，该缓冲块才能被再次分配。</p>
<blockquote>
<p>举一个可能引发异常的例子：每个缓冲块有一个进程等待队列，假设此时 B、C 两进程在队列中，当该缓冲块被解锁时，进程C被唤醒（它开始使用缓冲区之前需先唤醒进程 B，使进程 B 从挂起进入就绪状态），将缓冲区加锁。一段时间后，进程C又被挂起，但此时缓冲区由进程 C 在使用。此时，若进程B被调度，<code>if (bh-&gt;b_count)</code> 会注意到该缓冲区任是加锁状态，从而进程 B 重新选择缓冲区。如果没有这一额外判断，将造成进程 B 操作一个被加锁的缓冲区，引发异常。</p>
</blockquote>
<p>这一问题的本质在于竞争条件，是操作系统编程和并发编程中的一大难题。</p>
<h3 id="46-b-dirt-已经被置为1的缓冲块，同步前能够被进程继续读、写吗？为什么？给出代码证据。"><a href="#46-b-dirt-已经被置为1的缓冲块，同步前能够被进程继续读、写吗？为什么？给出代码证据。" class="headerlink" title="46. b_dirt 已经被置为1的缓冲块，同步前能够被进程继续读、写吗？为什么？给出代码证据。"></a>46. <code>b_dirt</code> 已经被置为1的缓冲块，同步前能够被进程继续读、写吗？为什么？给出代码证据。</h3><p>这样的缓冲块在同步前能够被继续读、写。 缓冲块是否能被进程读写，并不取决于 <code>b_dirt</code>，而取决于<code>b_uptodate</code>。只要 <code>b_uptodate</code> 为 <code>1</code>，缓冲块就能被进程读写。</p>
<p>这一设计背后的根源在于，我们并<strong>不在乎</strong>缓冲区是否与硬盘上的数据<strong>同步</strong>，而是<strong>希望</strong>缓冲区上的数据总是<strong>最新的</strong>，只有这样缓冲区才能成为硬盘数据的缓存。</p>
<p><strong>具体来说</strong>，读操作不会改变缓冲块中数据的内容，写操作后，改变了缓冲区内容，需要将 <code>b_dirt</code> 置 <code>1</code> ，为后面的写回做准备。而<code>b_uptodate</code> 设置为1后，内核便支持进程共享该缓冲块的数据了，读写均可。读操作不会改变缓冲块的内容，所以不影响数据；而执行写操作后，就改变了缓冲块的内容，就要将 <code>b_dirt</code> 标志设置为 <code>1</code> 。由于之前缓冲块已经和硬盘块更新了，所以后续同步过程中『缓冲块没有写入新数据的部分』和『原来硬盘对应的部分』相同，向硬盘同步时，所有的数据都是进程希望同步到硬盘数据块上的，不会把垃圾数据同步到硬盘上去。所以 <code>b_uptodate</code> 仍为 <code>1</code> 。所以， <code>b_dirt</code> 为 <code>1</code> ，进程仍能对缓冲区进行读写。</p>
<p>代码证据：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//代码路径：fs/block_dev.c</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">block_write</span><span class="params">(<span class="keyword">int</span> dev, <span class="keyword">long</span> * pos, <span class="keyword">char</span> * buf, <span class="keyword">int</span> count)</span><span class="comment">//块设备文件内容写入缓冲块</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        .......</span><br><span class="line">        offset = <span class="number">0</span>;</span><br><span class="line">        *pos += chars;</span><br><span class="line">        written += chars;</span><br><span class="line">        count -= chars;</span><br><span class="line">        <span class="keyword">while</span> (chars--&gt;<span class="number">0</span>)</span><br><span class="line">                *(p++) = get_fs_byte(buf++);</span><br><span class="line">        bh-&gt;b_dirt = <span class="number">1</span>; <span class="comment">// HERE!</span></span><br><span class="line">        brelse(bh);</span><br><span class="line">        .......</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 代码路径：fs/file_dev.c</span></span><br><span class="line"><span class="comment">// 将普通文件内容写入缓冲块</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">file_write</span><span class="params">(struct m_inode * inode, struct file * filp, <span class="keyword">char</span> * buf, <span class="keyword">int</span> count)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        ......</span><br><span class="line">        c = pos % BLOCK_SIZE;</span><br><span class="line">        p = c + bh-&gt;b_data;</span><br><span class="line">        bh-&gt;b_dirt = <span class="number">1</span>; <span class="comment">// HERE!</span></span><br><span class="line">        c = BLOCK_SIZE-c;</span><br><span class="line">        <span class="keyword">if</span> (c &gt; count-i) c = count-i;</span><br><span class="line">        pos += c;</span><br><span class="line">        <span class="keyword">if</span> (pos &gt; inode-&gt;i_size) &#123;</span><br><span class="line">                inode-&gt;i_size = pos;</span><br><span class="line">                inode-&gt;i_dirt = <span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">        i += c;</span><br><span class="line">        <span class="keyword">while</span> (c--&gt;<span class="number">0</span>)</span><br><span class="line">                *(p++) = get_fs_byte(buf++);</span><br><span class="line">        brelse(bh);</span><br><span class="line">        ......</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 代码路径：fs/namei.c</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> struct buffer_head * <span class="title">add_entry</span><span class="params">(struct m_inode * dir,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">const</span> <span class="keyword">char</span> * name, <span class="keyword">int</span> namelen, struct dir_entry ** res_dir)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        ......</span><br><span class="line">        <span class="keyword">if</span> (i*<span class="keyword">sizeof</span>(struct dir_entry) &gt;= dir-&gt;i_size) &#123;</span><br><span class="line">                de-&gt;inode=<span class="number">0</span>;</span><br><span class="line">                dir-&gt;i_size = (i+<span class="number">1</span>)*<span class="keyword">sizeof</span>(struct dir_entry);</span><br><span class="line">                dir-&gt;i_dirt = <span class="number">1</span>; <span class="comment">// HERE!</span></span><br><span class="line">                dir-&gt;i_ctime = CURRENT_TIME;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!de-&gt;inode) &#123;</span><br><span class="line">                dir-&gt;i_mtime = CURRENT_TIME;</span><br><span class="line">                <span class="keyword">for</span> (i=<span class="number">0</span>; i &lt; NAME_LEN ; i++)</span><br><span class="line">                        de-&gt;name[i]=(i&lt;namelen)?get_fs_byte(name+i):<span class="number">0</span>;</span><br><span class="line">                bh-&gt;b_dirt = <span class="number">1</span>; <span class="comment">// HERE!</span></span><br><span class="line">                *res_dir = de;</span><br><span class="line">                <span class="keyword">return</span> bh;</span><br><span class="line">        &#125;</span><br><span class="line">        ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="47-分析-panic-函数的源代码，根据你学过的操作系统知识，完整、准确的判断-panic-函数所起的作用。假如操作系统设计为支持内核进程（始终运行在0特权级的进程），你将如何改进-panic-函数？"><a href="#47-分析-panic-函数的源代码，根据你学过的操作系统知识，完整、准确的判断-panic-函数所起的作用。假如操作系统设计为支持内核进程（始终运行在0特权级的进程），你将如何改进-panic-函数？" class="headerlink" title="47. 分析 panic() 函数的源代码，根据你学过的操作系统知识，完整、准确的判断 panic() 函数所起的作用。假如操作系统设计为支持内核进程（始终运行在0特权级的进程），你将如何改进 panic() 函数？"></a>47. 分析 <code>panic()</code> 函数的源代码，根据你学过的操作系统知识，完整、准确的判断 <code>panic()</code> 函数所起的作用。假如操作系统设计为支持内核进程（始终运行在0特权级的进程），你将如何改进 <code>panic()</code> 函数？</h3><p> <code>panic()</code> 函数是当系统发现无法继续运行下去的故障时将调用它，会导致程序终止，然后由系统显示错误号。如果出现错误的函数不是进程0，那么就要进行数据同步，把缓冲区中的数据尽量同步到硬盘上。遵循了 Linux 尽量简明的原则。 改进 <code>panic</code> 函数：将死循环 <code>for(;;);</code> 改进为跳转到内核进程（始终运行在 0 特权级的进程），让内核继续执行。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 代码路径：kernel/panic.c</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/kernel.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/sched.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sys_sync</span><span class="params">(<span class="keyword">void</span>)</span></span>;	<span class="comment">/* it&#x27;s really int */</span></span><br><span class="line"><span class="function"><span class="keyword">volatile</span> <span class="keyword">void</span> <span class="title">panic</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> * s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	printk(<span class="string">&quot;Kernel panic: %s\\n\\r&quot;</span>,s);</span><br><span class="line">	<span class="keyword">if</span> (current == task[<span class="number">0</span>])</span><br><span class="line">		printk(<span class="string">&quot;In swapper task - not syncing\\n\\r&quot;</span>);</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		sys_sync();</span><br><span class="line">	<span class="keyword">for</span>(;;); <span class="comment">// HERE!</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="48-wait-on-buffer函数中为什么不用-if-而是用-while-？"><a href="#48-wait-on-buffer函数中为什么不用-if-而是用-while-？" class="headerlink" title="48. wait_on_buffer函数中为什么不用 if(...) 而是用 while(...) ？"></a>48. <code>wait_on_buffer</code>函数中为什么不用 <code>if(...)</code> 而是用 <code>while(...)</code> ？</h3><p><strong>一言以蔽之：因为竞争条件。</strong></p>
<p>考虑如下情况：若干($\ge2$)进程都在等待同一个缓冲块，构成了等待同一资源的进程等待队列。在缓冲块（资源）同步完毕后，会陆续唤醒各等待进程收取资源。陆续唤醒、轮到某一进程时，可能此时缓冲块已被刚刚被唤醒的前一进程<strong>重新</strong>占用，甚至加上了锁。因此进程被唤醒后需要重新检查资源是否可用，才能保证程序的正确性。</p>
<p>代码参考：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 代码路径：fs/buffer.c</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">wait_on_buffer</span><span class="params">(struct buffer_head * bh)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="comment">// 为进一步减少竞争条件，（在这一任务的控制流中）关闭中断</span></span><br><span class="line">        <span class="comment">// 这样禁止了时钟中断，从而避免了遭到被动调度、意外打断控制流的可能性。</span></span><br><span class="line">        cli();  </span><br><span class="line">        <span class="keyword">while</span> (bh-&gt;b_lock)</span><br><span class="line">                <span class="comment">// 为等待资源，主动睡眠</span></span><br><span class="line">                sleep_on(&amp;bh-&gt;b_wait); </span><br><span class="line">                <span class="comment">// 被唤醒后需要重新检查是否获得资源</span></span><br><span class="line">        <span class="comment">// 恢复中断</span></span><br><span class="line">        sti();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="49-操作系统如何利用-b-uptodate-保证缓冲块数据的正确性？-new-block-int-dev-函数新申请一个缓冲块后，并没有读盘，b-uptodate-却被置-1，是否会引起数据混乱？详细分析理由。"><a href="#49-操作系统如何利用-b-uptodate-保证缓冲块数据的正确性？-new-block-int-dev-函数新申请一个缓冲块后，并没有读盘，b-uptodate-却被置-1，是否会引起数据混乱？详细分析理由。" class="headerlink" title="49. 操作系统如何利用 b_uptodate 保证缓冲块数据的正确性？ new_block(int dev) 函数新申请一个缓冲块后，并没有读盘，b_uptodate 却被置 1，是否会引起数据混乱？详细分析理由。"></a>49. 操作系统如何利用 <code>b_uptodate</code> 保证缓冲块数据的正确性？ <code>new_block(int dev)</code> 函数新申请一个缓冲块后，并没有读盘，<code>b_uptodate</code> 却被置 <code>1</code>，是否会引起数据混乱？详细分析理由。</h3><p><code>b_uptodate</code> 是缓冲块管理结构中的标志位，它的作用是告诉内核「缓冲块中的数据是否是最新的」。</p>
<p><strong>当从硬盘读取已有文件时</strong>，<code>b_uptodate</code> 意味着硬盘上的数据是否已经同步到缓冲块中。置 <code>1</code> 时，说明缓冲块中的数据已完成同步，内核可以放心地支持进程与缓冲块进行数据交互；如果 <code>b_uptodate</code> 为 <code>0</code>，就提醒内核最新的数据还没有同步到该缓冲块上，向该缓冲块写入会导致竞争，因此也不支持进程共享该缓冲块。</p>
<p><strong>为新建文件（或为文件添加的新数据）创建一个缓冲块时</strong>，<code>b_uptodate</code> 被置 <code>1</code>，这是因为此时的新文件刚刚由用户建立，<strong>本身就是最新的</strong>，硬盘上的内容才是“垃圾数据”、是落后的一方。因此，缓冲块中的 <code>b_uptodate</code> 被置为 <code>1</code>，不会引起混乱，而是读写逻辑需求导致。</p>
<blockquote>
<p>严格来说，新建的数据块还可能用于存储文件的 <code>i_zone</code> 间接块管理信息。</p>
<p>如果是间接块管理信息，缓冲区必须清零，表示没有索引间接数据块，否则垃圾数据会导致索引错误，破坏文件操作的正确性。虽然缓冲块与硬盘数据块的数据不一致，但缓冲块上是更加新的数据，将 <code>b_uptodate</code> 置 <code>1</code> 同样不会有问题。</p>
<p>综上所述，设计者采用的策略如下：只要为<strong>新建的数据块新申请了缓冲块</strong>，不论该缓冲块将来用作什么，由于进程不需要里面原有的数据，干脆全部清零。这样不管与之绑定的数据块用来存储什么信息，都无所谓，同时将该缓冲块的 <code>b_uptodate</code> 字段设置为 <code>1</code>，更新问题“等效于”已解决。</p>
</blockquote>
<h3 id="50-add-request-函数中有下列代码，其中的前两行（不含括号）是什么意思？"><a href="#50-add-request-函数中有下列代码，其中的前两行（不含括号）是什么意思？" class="headerlink" title="50. add_request() 函数中有下列代码，其中的前两行（不含括号）是什么意思？"></a>50. <code>add_request()</code> 函数中有下列代码，其中的前两行（不含括号）是什么意思？</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 代码路径：kernel/blk_drv/ll_rw_blk.c/add_request(...)</span></span><br><span class="line"><span class="keyword">if</span> (!(tmp = dev-&gt;current_request)) </span><br><span class="line">&#123;        </span><br><span class="line">        dev-&gt;current_request = req;        </span><br><span class="line">        sti();       </span><br><span class="line">        (dev-&gt;request_fn)();        </span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>前两行为：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!(tmp = dev-&gt;current_request)) </span><br><span class="line">&#123;        </span><br><span class="line">        dev-&gt;current_request = req;</span><br><span class="line">        ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这两行查看指定设备是否有当前请求项，即查看设备是否忙。如果指定设备 <code>dev</code> 当前请求项 <code>dev-&gt;current_request</code>  为空，则表示目前设备没有请求项。本次是头一个请求项，也是当前唯一的一个请求项。因此：</p>
<ol>
<li>可将「块设备当前请求指针」直接指向该请求项，</li>
<li>需要手动触发「相应设备的请求函数」——这一函数在请求队列非空时循环执行，但请求队列清空后便停止执行。因此放入新请求项时需要再次手动触发。</li>
</ol>
<h3 id="51-do-hd-request-函数中-dev-的含义始终一样吗？"><a href="#51-do-hd-request-函数中-dev-的含义始终一样吗？" class="headerlink" title="51. do_hd_request() 函数中 dev 的含义始终一样吗？"></a>51. <code>do_hd_request()</code> 函数中 <code>dev</code> 的含义始终一样吗？</h3><p>不一样。 <code>do_hd_request()</code> 函数主要用于处理当前硬盘请求项，但其中的 <code>dev</code> 变量含义并不一致。<code>dev = MINOR(CURRENT-&gt;dev)</code> 意味着取硬盘的逻辑设备号，对硬盘来说，为「物理硬盘号x5+硬盘上的分区号」。<code>dev/=5</code> 这一指令后表示的实际的物理设备号，即「第几块物理硬盘」。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//代码路径：kernel/blk_drv/hd.c</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">do_hd_request</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i,r;</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">int</span> block,dev;</span><br><span class="line">        ......</span><br><span class="line">        dev = MINOR(CURRENT-&gt;dev); <span class="comment">// HERE!</span></span><br><span class="line">        block = CURRENT-&gt;sector;</span><br><span class="line">        <span class="keyword">if</span> (dev &gt;= <span class="number">5</span>*NR_HD || block+<span class="number">2</span> &gt; hd[dev].nr_sects) &#123;</span><br><span class="line">                end_request(<span class="number">0</span>);</span><br><span class="line">                <span class="keyword">goto</span> repeat;</span><br><span class="line">        &#125;</span><br><span class="line">        block += hd[dev].start_sect;</span><br><span class="line">        dev /= <span class="number">5</span>; <span class="comment">// HERE!</span></span><br><span class="line">        ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>为什么会有这样复杂的设备号约定呢？Linux 0.11 中，设备号分为主设备号和次设备号。其中，硬盘的主设备号是 3。其它设备的主设备号分别为：</p>
<blockquote>
<p>1-内存，2-磁盘， 3-硬盘， 4-ttyx， 5-tty，6-并行口，7-非命名管道</p>
</blockquote>
<p>由于 1 个硬盘中可以存在 1-4 个分区，因此硬盘还依据分区的不同用次设备号进行指定分区。因此，硬盘的逻辑设备号由以下方式构成：</p>
<blockquote>
<p>设备号=主设备号*256 + 次设备号</p>
</blockquote>
<p>以两个硬盘、每个硬盘上有四个分区为例，具体的硬盘号如下表所示：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>逻辑设备号</th>
<th>对应设备文件</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>0x300</code></td>
<td><code>/dev/hd0</code></td>
<td>代表整个第 1 个硬盘</td>
</tr>
<tr>
<td><code>0x301</code></td>
<td><code>/dev/hd1</code></td>
<td>表示第 1 个硬盘的第 1 个分区</td>
</tr>
<tr>
<td><code>0x302</code></td>
<td><code>/dev/hd2</code></td>
<td>表示第 1 个硬盘的第 2 个分区</td>
</tr>
<tr>
<td><code>0x303</code></td>
<td><code>/dev/hd3</code></td>
<td>表示第 1 个硬盘的第 3 个分区</td>
</tr>
<tr>
<td><code>0x304</code></td>
<td><code>/dev/hd4</code></td>
<td>表示第 1 个硬盘的第 4 个分区</td>
</tr>
<tr>
<td><code>0x305</code></td>
<td><code>/dev/hd5</code></td>
<td>代表整个第 2 个硬盘</td>
</tr>
<tr>
<td><code>0x306</code></td>
<td><code>/dev/hd6</code></td>
<td>表示第 2 个硬盘的第 1 个分区</td>
</tr>
<tr>
<td><code>0x307</code></td>
<td><code>/dev/hd7</code></td>
<td>表示第 2 个硬盘的第 2 个分区</td>
</tr>
<tr>
<td><code>0x308</code></td>
<td><code>/dev/hd8</code></td>
<td>表示第 2 个硬盘的第 3 个分区</td>
</tr>
<tr>
<td><code>0x309</code></td>
<td><code>/dev/hd9</code></td>
<td>表示第 2 个硬盘的第 4 个分区</td>
</tr>
</tbody>
</table>
</div>
<p>从 linux 内核 0.95 版后已经<strong>不使用</strong>这种烦琐的命名方式，而是使用与现在相同的命名方法了。</p>
<h3 id="52-read-intr-函数中，下列代码是什么意思？为什么这样做？"><a href="#52-read-intr-函数中，下列代码是什么意思？为什么这样做？" class="headerlink" title="52. read_intr() 函数中，下列代码是什么意思？为什么这样做？"></a>52. <code>read_intr()</code> 函数中，下列代码是什么意思？为什么这样做？</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 代码路径：kernel/blk_drv/hd.c/read_intr()</span></span><br><span class="line"><span class="keyword">if</span> (--CURRENT-&gt;nr_sectors) &#123;        </span><br><span class="line">        do_hd = &amp;read_intr;        </span><br><span class="line">        <span class="keyword">return</span>;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>read_intr()</code> 是对磁盘发出读取请求后操作系统用于处理磁盘返回中断的函数。当读取扇区操作成功后，<code>-—CURRENT-&gt;nr_sectors</code> 递减请求项所需读取的扇区数值。若递减后不等于 <code>0</code>，表示本项请求<strong>还有扇区没读完</strong>，于是<strong>再次置中断调用</strong>函数指针 <code>do_hd = &amp;read_intr;</code> 并直接返回，等待硬盘在读出下一扇区数据后发出中断并再次调用本函数。</p>
<h3 id="53-bread-函数代码中为什么要做第二次-if-bh-gt-b-uptodate-判断？"><a href="#53-bread-函数代码中为什么要做第二次-if-bh-gt-b-uptodate-判断？" class="headerlink" title="53. bread() 函数代码中为什么要做第二次 if (bh-&gt;b_uptodate) 判断？"></a>53. <code>bread()</code> 函数代码中为什么要做第二次 <code>if (bh-&gt;b_uptodate)</code> 判断？</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 代码路径：fs/buffer.c/bread(int dev, int block)</span></span><br><span class="line"><span class="keyword">if</span> (bh-&gt;b_uptodate)</span><br><span class="line">        <span class="keyword">return</span> bh;</span><br><span class="line">ll_rw_block(READ,bh);</span><br><span class="line">wait_on_buffer(bh);</span><br><span class="line"><span class="keyword">if</span> (bh-&gt;b_uptodate)</span><br><span class="line">        <span class="keyword">return</span> bh;</span><br></pre></td></tr></table></figure>
<p><code>bread()</code> 函数的功能是向内核中的上层函数提供从块设备上读取数据块的函数接口，而内部则为数据块加了一层 RAM 上的缓冲区作为块数据的缓存。</p>
<p><code>bread()</code> 会调用底层 <code>ll_rw_block()</code> 函数，产生读设备请求。然后等待指定数据块读入，并等待缓冲块解锁。在睡眠醒来之后，如果缓冲块已更新 <code>if (bh-&gt;b_uptodate)</code>，则返回缓冲块指针。否则，表明读设备操作失败，于是释放该缓冲块返回 <code>NULL</code>。</p>
<p><strong>第一次</strong>检查：从高速缓冲区中取出需要的缓冲块， 判断缓冲块数据是否已同步，已读取过（严格来说要求缓冲块中数据时最新的）则返回此块。如果该缓冲块数据无效（更新标志未置位——这往往意味着缓冲块中的数据还没有从磁盘中读取）， 则向设备发送数据块读取请求。 第二次检查：等指定数据块被读入，并且缓冲区解锁，睡眠醒来之后，要重新判断缓冲块是否有效。在睡眠等待过程中，数据可能已经发生了改变，所以要第二次判断。</p>
<h3 id="54-getblk-函数中，两次调用-wait-on-buffer-函数，两次的意思一样吗？"><a href="#54-getblk-函数中，两次调用-wait-on-buffer-函数，两次的意思一样吗？" class="headerlink" title="54. getblk() 函数中，两次调用 wait_on_buffer() 函数，两次的意思一样吗？"></a>54. <code>getblk()</code> 函数中，两次调用 <code>wait_on_buffer()</code> 函数，两次的意思一样吗？</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 代码路径：fs/buffer.c</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BADNESS(bh) (((bh)-&gt;b_dirt<span class="meta-string">&lt;&lt;1)+(bh)-&gt;</span>b_lock)</span></span><br><span class="line"><span class="function">struct buffer_head * <span class="title">getblk</span><span class="params">(<span class="keyword">int</span> dev,<span class="keyword">int</span> block)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">buffer_head</span> * <span class="title">tmp</span>, * <span class="title">bh</span>;</span></span><br><span class="line"></span><br><span class="line">repeat:</span><br><span class="line">        <span class="keyword">if</span> (bh = get_hash_table(dev,block))</span><br><span class="line">                <span class="keyword">return</span> bh;</span><br><span class="line">        tmp = free_list;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (tmp-&gt;b_count)</span><br><span class="line">                        <span class="keyword">continue</span>; <span class="comment">// 问题37中的continue</span></span><br><span class="line">                <span class="keyword">if</span> (!bh || BADNESS(tmp)&lt;BADNESS(bh)) &#123;</span><br><span class="line">                        bh = tmp;</span><br><span class="line">                        <span class="keyword">if</span> (!BADNESS(tmp))</span><br><span class="line">                                <span class="keyword">break</span>; <span class="comment">// 问题37中的break</span></span><br><span class="line">                &#125;</span><br><span class="line"><span class="comment">/* and repeat until we find something good */</span></span><br><span class="line">        &#125; <span class="keyword">while</span> ((tmp = tmp-&gt;b_next_free) != free_list);</span><br><span class="line">        <span class="keyword">if</span> (!bh) &#123;</span><br><span class="line">                sleep_on(&amp;buffer_wait);</span><br><span class="line">                <span class="keyword">goto</span> repeat;</span><br><span class="line">        &#125;</span><br><span class="line">        wait_on_buffer(bh); <span class="comment">// 第一处</span></span><br><span class="line">        <span class="keyword">if</span> (bh-&gt;b_count)</span><br><span class="line">                <span class="keyword">goto</span> repeat;</span><br><span class="line">        <span class="keyword">while</span> (bh-&gt;b_dirt) &#123;</span><br><span class="line">                sync_dev(bh-&gt;b_dev);</span><br><span class="line">                wait_on_buffer(bh); <span class="comment">// 第二处</span></span><br><span class="line">                <span class="keyword">if</span> (bh-&gt;b_count)</span><br><span class="line">                        <span class="keyword">goto</span> repeat;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">/* NOTE!! While we slept waiting for this block, somebody else might */</span></span><br><span class="line"><span class="comment">/* already have added &quot;this&quot; block to the cache. check it */</span></span><br><span class="line">        <span class="keyword">if</span> (find_buffer(dev,block))</span><br><span class="line">                <span class="keyword">goto</span> repeat;</span><br><span class="line">        ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>相同又不同。都是等待缓冲块解锁，这是相同之处。</p>
<p><strong>第一次调用</strong>是无条件的，已找到一个比较合适的空闲缓冲块 (<code>bh-&gt;b_count==0</code>)，但是此块可能是加锁的（往往是因为正在同步至硬盘），于是等待该缓冲块解锁。</p>
<p><strong>第二次调用</strong>， 是针对此块中原先的数据已被修改过（”脏的“）但尚未同步的情况，于是</p>
<ol>
<li>先下达把数据同步到硬盘上的指令 <code>sync_dev(bh-&gt;b_dev)</code></li>
<li>同步时会加锁， 所以随后需要等待缓冲块解锁，即下一行的 <code>wait_on_buffer(bh)</code>。</li>
</ol>
<p>值得注意的是，<code>wait_on_buffer(bh)</code> 时原则上可能有一整个缓冲队列（多个进程）在等待同一资源，因此等待结束后、当前进程调度前可能被其它进程抢先占据了资源，因此 Linus 又做了额外判断作为保险：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (bh-&gt;b_count) <span class="comment">// 缓冲块又被其它某个进程先拿走了</span></span><br><span class="line">        <span class="keyword">goto</span> repeat;</span><br></pre></td></tr></table></figure>
<p>当然，对缓冲块而言这种情况发生的频率应当是很低的。</p>
<h3 id="55-getblk-函数中，说明什么情况下执行-continue-、break。"><a href="#55-getblk-函数中，说明什么情况下执行-continue-、break。" class="headerlink" title="55. getblk() 函数中，说明什么情况下执行 continue 、break。"></a>55. <code>getblk()</code> 函数中，<strong>说明什么情况下执行 <code>continue</code> 、<code>break</code>。</strong></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 代码路径：fs/buffer.c/getblk(...)</span></span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (tmp-&gt;b_count)</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span> (!bh || BADNESS(tmp)&lt;BADNESS(bh)) &#123; </span><br><span class="line">                bh = tmp;</span><br><span class="line">                <span class="keyword">if</span> (!BADNESS(tmp)) </span><br><span class="line">                        <span class="keyword">break</span>; </span><br><span class="line">        &#125;</span><br><span class="line">&#125; <span class="keyword">while</span> ((tmp = tmp-&gt;b_next_free) != free_list);</span><br></pre></td></tr></table></figure>
<p><code>getblk()</code> 函数主要是获取高速缓冲中的指定缓冲块。但缓冲块有可能正在被其它进程使用、有可能内容已修改需要写回，有可能正在写回，情况复杂。如何选取最合适的缓冲块，就成了这段代码要解决的问题。</p>
<p>缓冲块的参数指标有三个：</p>
<ol>
<li><code>bh-&gt;b_count</code> 是缓冲块的引用计数，指明缓冲块被多少个进程使用。</li>
<li><code>bh-&gt;b_dirt</code> 指明缓冲块的内容是否被修改过。如果被修改过后又要写入新内容，那原来的内容就需要先同步回磁盘。</li>
<li><code>bh-&gt;b_lock</code> 是缓冲块的锁，指明缓冲块已被某个进程拥有且正在进行一些不可打断的原子操作。例如，某个进程正在同步缓冲块至磁盘时会给缓冲块加上锁。</li>
</ol>
<p><code>free_list</code> 是一个将<strong>所有缓冲块</strong>串在一起的双向链表。虽叫 “free” list，但实际上并不是包含所有空闲缓冲块的链表，而是一个大致表明缓冲块“空闲程度”的优先队列。每个缓冲块被使用过后会被挪移到链表的末尾，因此<strong>距离上次使用时间越长的缓冲块便会越接近链表的队头</strong>。因此这一链表逻辑上是一个优先队列，起到了类似 LRU 缓存策略的功能。</p>
<p>下面我们回到问题，作具体分析。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 代码路径：fs/buffer.c/getblk(...)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BADNESS(bh) (((bh)-&gt;b_dirt<span class="meta-string">&lt;&lt;1)+(bh)-&gt;</span>b_lock)</span></span><br><span class="line">...</span><br><span class="line"><span class="keyword">if</span> (bh = get_hash_table(dev,block))</span><br><span class="line">        <span class="keyword">return</span> bh;</span><br><span class="line">        tmp = free_list;</span><br><span class="line"><span class="comment">// 1. 走到此处意味着 bh==NULL，且说明函数希望读取的内容不在任何一个已有的缓冲块中。</span></span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (tmp-&gt;b_count)</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">        <span class="comment">// 2. 走到此处意味着 tmp-&gt;b_count==0</span></span><br><span class="line">        <span class="keyword">if</span> (!bh || BADNESS(tmp)&lt;BADNESS(bh)) &#123; </span><br><span class="line">                <span class="comment">// 3. 走到这一分支意味着我们有更好的缓冲块选择</span></span><br><span class="line">                bh = tmp;</span><br><span class="line">                <span class="keyword">if</span> (!BADNESS(tmp)) </span><br><span class="line">                        <span class="comment">// 4. 走到这一路径说明BADNESS(tmp)==00，完美符合我们的要求，直接退出循环</span></span><br><span class="line">                        <span class="keyword">break</span>; </span><br><span class="line">        &#125;</span><br><span class="line">&#125; <span class="keyword">while</span> ((tmp = tmp-&gt;b_next_free) != free_list);</span><br></pre></td></tr></table></figure>
<ol>
<li><code>get_hash_table(...)</code> 会试图找到已经被缓存的块并直接返回，若找不到则返回 <code>NULL</code>。因此若代码运行至 1 处，说明在已有的缓冲区中找不到需要的内容，需要从硬盘中读取内容再返回。</li>
<li>随后函数遍历 <code>free_list</code> 寻找合适的缓冲块。由于是从前向后遍历，距上次使用时间更长的块更有可能被选中。若该缓冲块引用计数不为零，说明正在被其它进程使用；又因为「需要读取的内容」和「任意已有缓冲块中内容」都不一样，不可能使用该缓冲块。直接跳过，即运行 <code>continue</code>。</li>
<li>若程序运行到 3 处，说明找到了一个不被其它进程使用的缓冲块，可以处理掉其中内容之后读取新内容。这样的缓冲块能用就行，但如果不脏就更好了。</li>
<li>若程序运行到 4 处，说明着找到了一个既没有被其它进程使用，也没有被修改过，也没有被加锁的缓冲块。这意味着找到了一个完美的空闲缓冲块，因此直接退出循环，即运行 <code>break</code>。</li>
</ol>
<h3 id="56-make-request-函数-，其中的-sleep-on-amp-wait-for-request-是谁在等？等什么？"><a href="#56-make-request-函数-，其中的-sleep-on-amp-wait-for-request-是谁在等？等什么？" class="headerlink" title="56. make_request() 函数 ，其中的 sleep_on(&amp;wait_for_request) 是谁在等？等什么？"></a>56. <code>make_request()</code> 函数 ，其中的 <code>sleep_on(&amp;wait_for_request)</code> 是谁在等？等什么？</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 代码路径：kernel/blk_drv/ll_rw_blk.c/make_request(...)</span></span><br><span class="line"><span class="keyword">if</span> (req &lt; request) &#123;</span><br><span class="line">        <span class="keyword">if</span> (rw_ahead) &#123;</span><br><span class="line">                unlock_buffer(bh);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        sleep_on(&amp;wait_for_request);</span><br><span class="line">        <span class="keyword">goto</span> repeat;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这行代码等待的资源是空闲请求项，等待的进程是包括当前进程在内的所有需要这一资源的进程。</p>
<p><code>make_request()</code> 函数主要功能为「创建请求项并将其插入请求队列」。执行 <code>if</code> 分支中的内容说明没有找到空请求项，即请求项数组 <code>request[32]</code> 中没有一项是空闲的。因此让进程暂停，等待前面的读写任务完成，等待请求项释放。</p>
<blockquote>
<p>严格来说，是没有满足条件的请求项，因为读写操作的可用请求项部分不完全一样，写操作能够占用的请求项只有前 <code>32*2/3=21</code> 个。</p>
<p>如果是预读取请求（即 <code>rw_ahead</code>），那么在这种情况下便直接放弃。</p>
</blockquote>
<h3 id="57-操作系统如何处理多个进程等待同一个正在与硬盘交互的缓冲块？"><a href="#57-操作系统如何处理多个进程等待同一个正在与硬盘交互的缓冲块？" class="headerlink" title="57. 操作系统如何处理多个进程等待同一个正在与硬盘交互的缓冲块？"></a>57. 操作系统如何处理多个进程等待同一个正在与硬盘交互的缓冲块？</h3><p>对于一个正在与硬盘交互的缓冲块，操作系统将其加锁。进程遇到加锁的缓冲块，需要执行 <code>wait_on_buffer</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 代码路径：fs/buffer.c</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">wait_on_buffer</span><span class="params">(struct buffer_head * bh)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        cli();</span><br><span class="line">        <span class="keyword">while</span> (bh-&gt;b_lock)</span><br><span class="line">                sleep_on(&amp;bh-&gt;b_wait);</span><br><span class="line">        sti();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 <code>wait_on_buffer</code> 中，如果缓冲块加锁，进程需要执行 <code>sleep_on</code> 函数。<code>sleep_on</code> 函数中，先将当前进程记录到 <code>p=&amp;bh-&gt;b_wait</code> 中，供日后唤醒。然后将当前进程挂起、设置为不可打断的等待状态，最后调用 <code>schedule()</code> 切换至其它进程执行，直到当前进程被唤醒。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 代码路径：kernel/sched.c</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sleep_on</span><span class="params">(struct task_struct **p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        ......</span><br><span class="line">        *p = current;</span><br><span class="line">        current-&gt;state = TASK_UNINTERRUPTIBLE;</span><br><span class="line">        schedule();</span><br><span class="line">        ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然而，一种更复杂的情况是多个进程等待同一个资源，例如，多个进程同时等待某个正在与硬盘交互的缓冲块。这时，当进程试图睡眠时 <code>bh-&gt;b_wait</code> 已经是一个非空值，里面保存着之前已经在等待的进程。为此，<code>sleep_on</code> 会先将 <code>p=&amp;bh-&gt;b_wait</code> 中的内容暂存到 <code>tmp</code> 中，当自己被唤醒后再唤醒 <code>tmp</code> 中指向的进程。这样一来，所有等待同一资源的进程都会被唤醒。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 代码路径：kernel/sched.c</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sleep_on</span><span class="params">(struct task_struct **p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">tmp</span>;</span> <span class="comment">// HERE!!</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!p)</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span> (current == &amp;(init_task.task))</span><br><span class="line">                panic(<span class="string">&quot;task[0] trying to sleep&quot;</span>);</span><br><span class="line">        tmp = *p; <span class="comment">// 将进程</span></span><br><span class="line">        *p = current;</span><br><span class="line">        current-&gt;state = TASK_UNINTERRUPTIBLE;</span><br><span class="line">        schedule();</span><br><span class="line">        <span class="keyword">if</span> (tmp) <span class="comment">// 唤醒tmp指向的进程</span></span><br><span class="line">                tmp-&gt;state=<span class="number">0</span>; <span class="comment">//=TASK_RUNNING</span></span><br><span class="line">&#125;</span><br><span class="line">......</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">wake_up</span><span class="params">(struct task_struct **p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (p &amp;&amp; *p) &#123;</span><br><span class="line">                (**p).state=<span class="number">0</span>;</span><br><span class="line">                *p=<span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>某一时刻，多个等待某资源的进程的 <code>sleep_on</code> 函数中可能有多个 <code>tmp</code> 变量，依次指向这条“等待链”中的下一个进程。这时，函数中的临时指针 <code>tmp</code> 其实构成了一个隐式的等待队列，由该资源的 <code>wait</code> 指针（对缓冲块而言，是缓冲头中的 <code>bh-&gt;b_wait</code>）指向队列的队头（见下图）。唤醒时，由队头向后依次唤醒等待队列中的所有进程（见代码）。</p>
<div align="center">
<img src="/2022/12/31/Linux-0-11-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%E4%B8%8E%E6%80%9D%E8%80%83%E9%A2%98/wait_list.png" alt="多个进程等待同一资源时形成的隐式队列[3]"><br>
</div>

<h3 id="58-add-request-函数中有下列代码"><a href="#58-add-request-函数中有下列代码" class="headerlink" title="58. add_request() 函数中有下列代码"></a>58. <code>add_request()</code> 函数中<strong>有下列代码</strong></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 代码路径：kernel/blk_drv/ll_rw_blk.c/add_request(...)</span></span><br><span class="line"><span class="keyword">if</span> (!(tmp = dev-&gt;current_request)) &#123;</span><br><span class="line">        dev-&gt;current_request = req;</span><br><span class="line">        sti();</span><br><span class="line">        (dev-&gt;request_fn)();</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>其中的</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!(tmp = dev-&gt;current_request)) &#123;</span><br><span class="line">        dev-&gt;current_request = req;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>是什么意思？</strong></p>
<p>查看指定设备是否有当前请求项，即查看设备是否忙。如果指定设备当前请求项为空，则表示目前设备没有请求项 (<code>dev-&gt;current_request ==NULL</code>)，本次是第一个请求项，也是唯一的一个。因此可将块设备当前请求指针直接指向该请求项，并立即执行相应设备的请求函数。</p>
<h3 id="59-操作系统如何利用-buffer-head-中的-b-data-b-blocknr-b-dev-b-uptodate-b-dirt-b-count-b-lock-b-wait-字段管理缓冲块的？"><a href="#59-操作系统如何利用-buffer-head-中的-b-data-b-blocknr-b-dev-b-uptodate-b-dirt-b-count-b-lock-b-wait-字段管理缓冲块的？" class="headerlink" title="59. 操作系统如何利用 buffer_head 中的 b_data, b_blocknr, b_dev, b_uptodate, b_dirt, b_count, b_lock, b_wait 字段管理缓冲块的？"></a>59. <strong>操作系统如何利用 <code>buffer_head</code> 中的 <code>b_data, b_blocknr, b_dev, b_uptodate, b_dirt, b_count, b_lock, b_wait</code> 字段管理缓冲块的？</strong></h3><p>管理缓冲块的「缓冲块头结构」<code>struct buffer_head</code> 在源代码中的定义如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 代码路径：include/linux/fs.h</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">buffer_head</span> &#123;</span></span><br><span class="line">        <span class="keyword">char</span> * b_data;                  <span class="comment">/* pointer to data block (1024 bytes) */</span></span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">long</span> b_blocknr;        <span class="comment">/* block number */</span></span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">short</span> b_dev;           <span class="comment">/* device (0 = free) */</span></span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">char</span> b_uptodate;</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">char</span> b_dirt;           <span class="comment">/* 0-clean,1-dirty */</span></span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">char</span> b_count;          <span class="comment">/* users using this block */</span></span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">char</span> b_lock;           <span class="comment">/* 0 - ok, 1 -locked */</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> * <span class="title">b_wait</span>;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">buffer_head</span> * <span class="title">b_prev</span>;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">buffer_head</span> * <span class="title">b_next</span>;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">buffer_head</span> * <span class="title">b_prev_free</span>;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">buffer_head</span> * <span class="title">b_next_free</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>「缓冲块头结构」<code>buffer_head</code> 负责管理缓冲块以及进程与缓冲块的交互。</p>
<p><code>b_data</code> 指向被管理的缓冲块数据。</p>
<p><code>b_dev,b_blocknr</code> 是缓冲块中缓冲的数据（若有）的设备号（例如，硬盘的某个分区）和逻辑块号。</p>
<p>内核在 <code>hash_table</code> 表中搜索带有某内容的缓冲块时，只看设备号与块号（即 <code>b_dev</code> 和 <code>b_blocknr</code>）。只要缓冲块与硬盘数据的绑定关系还在，就认定数据块仍停留在缓冲块中，就可以直接返回、使用。</p>
<p><code>b_uptodate</code> 与 <code>b_dirt</code>，是为了解决缓冲块的数据同步性而引入的两个标志。</p>
<p><code>b_uptodate</code> 指明缓冲块中的内容是否是最新的。如果 <code>b_uptodate</code> 为 <code>1</code>，说明缓冲块的数据已经是数据块中最新的，可以支持进程共享缓冲块中的数据；如果 <code>b_uptodate</code> 为 <code>0</code>，提醒内核缓冲块并没有用绑定的数据块中的数据更新，不支持进程共享该缓冲块。当一个缓冲块中未载入硬盘上的数据时，缓冲块的 <code>b_uptodate</code> 为 <code>0</code>；当进程修改了某些内容而未同步入缓冲块中时， <code>b_uptodate</code> 也会置零。</p>
<p><code>b_dirt</code> 是标记缓冲块中的内容是否被进程修改过了（“脏位”）。为 <code>1</code> 说明缓冲块的内容被进程方向的改写了，最终需要同步到硬盘上；<code>b_dirt</code> 为 <code>0</code> 则说明不需要同步。</p>
<p><code>b_count</code> 记录每个缓冲块有多少进程共享，即引用计数。<code>b_count</code> 大于 0 表明有进程在共享该缓冲块；当进程不需要共享缓冲块时，内核会解除该进程与缓冲块的关系，并将 <code>b_count</code> 数值减 1，为 0 表明可以被当作新缓冲块来申请使用。</p>
<p><code>b_lock</code> 为缓冲块的“加锁”标记。具体来说，为 1 说明缓冲块正与硬盘交互，内核会拦截进程对此时该缓冲块的操作，以免发生错误。交互完成后，置0，表明进程可以操作该缓冲块。</p>
<p><code>b_wait</code> 记录等待缓冲块的解锁而被挂起的进程，指向等待队列的第一个进程的 <code>task_struct</code>。</p>
<h3 id="60-用图表示下面的几种情况，并从代码中找到证据："><a href="#60-用图表示下面的几种情况，并从代码中找到证据：" class="headerlink" title="60. 用图表示下面的几种情况，并从代码中找到证据："></a>60. <strong>用图表示下面的几种情况，并从代码中找到证据：</strong></h3><ul>
<li><strong>(a) 当进程获得第一个缓冲块的时候，哈希表 <code>hash_table</code> 的状态。</strong></li>
<li><strong>(b) 经过一段时间的运行，已经有 2000 多个 <code>buffer_head</code> 挂到 <code>hash_table</code> 上时，hash 表（包括所有的 <code>buffer_head</code>）的整体运行状态。</strong></li>
<li><strong>(c) 经过一段时间的运行，有的缓冲块已经不被进程使用了（空闲），这样的空闲缓冲块是否会从 <code>hash_table</code> 上脱钩？</strong></li>
<li><strong>(d) 经过一段时间的运行，所有的 <code>buffer_head</code> 都挂到 <code>hash_table</code> 上了，这时，又有进程申请空闲缓冲块，将会发生什么？</strong></li>
</ul>
<p>(a) Linux-0.11 中，采用了两种管理缓冲块的数据结构：一个哈希表 <code>hash_table[307]</code>，用于根据设备号和块号快速找到需要的缓冲块（如果有的话）；和一个实现为双向链环的优先队列 <code>free_list</code>，用于按序存储 least recently used 的缓冲块。代码证据如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 代码路径：fs/buffer.c</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">buffer_head</span> * <span class="title">hash_table</span>[<span class="title">NR_HASH</span>];</span> <span class="comment">// NR_HASH=307</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">buffer_head</span> * <span class="title">free_list</span>;</span></span><br><span class="line">......</span><br><span class="line"><span class="comment">// 哈希函数：(dev XOR block) mod 307</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _hashfn(dev,block) (((unsigned)(dev^block))%NR_HASH)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> hash(dev,block) hash_table[_hashfn(dev,block)]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 管理两个数据结构的函数有很多，这里挑选了一个最有代表性的函数</span></span><br><span class="line"><span class="comment">// 插入队列时将bh放在最后，也说明free_list是一个按LRU顺序排列的优先队列</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">insert_into_queues</span><span class="params">(struct buffer_head * bh)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">/* put at end of free list */</span></span><br><span class="line">        bh-&gt;b_next_free = free_list;</span><br><span class="line">        bh-&gt;b_prev_free = free_list-&gt;b_prev_free;</span><br><span class="line">        free_list-&gt;b_prev_free-&gt;b_next_free = bh;</span><br><span class="line">        free_list-&gt;b_prev_free = bh;</span><br><span class="line"><span class="comment">/* put the buffer in new hash-queue if it has a device */</span></span><br><span class="line">        bh-&gt;b_prev = <span class="literal">NULL</span>;</span><br><span class="line">        bh-&gt;b_next = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">if</span> (!bh-&gt;b_dev)</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">        bh-&gt;b_next = hash(bh-&gt;b_dev,bh-&gt;b_blocknr);</span><br><span class="line">        hash(bh-&gt;b_dev,bh-&gt;b_blocknr) = bh;</span><br><span class="line">        bh-&gt;b_next-&gt;b_prev = bh;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>假设第一个缓冲块挂在了 <code>hash_table[1]</code> 上，此时哈希表的状态如下图所示：</p>
<div align="center">
<img src="/2022/12/31/Linux-0-11-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%E4%B8%8E%E6%80%9D%E8%80%83%E9%A2%98/hash_table_a.png" alt="只有一个缓冲块时的数据结构" style="zoom:50%;"><br>
</div>



<p>(b) 运行一段时间、有很多缓冲块被挂在哈希表上时，整体的运行状态大致如下图所示：</p>
<div align="center">
<img src="/2022/12/31/Linux-0-11-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%E4%B8%8E%E6%80%9D%E8%80%83%E9%A2%98/hash_table_b.png" alt="许多缓冲块时的数据结构[3]" style="zoom:50%;"><br>
</div>


<p>(c) 不会。缓冲区的设计原则是让缓冲块尽可能久地停留在内存中，从而便于随后重用、减少访存时间。即使一个缓冲块的引用计数减至零，也不会被直接从哈希表上拿走，而是留在内存中，直到重新被引用，或者为了缓冲其它内容而被覆盖。</p>
<p>(d) 为了获取新的、可用的缓冲块，内核沿 <code>free_list</code> 依次遍历查找 least recently used 的缓冲块：</p>
<ol>
<li>引用计数为零(<code>b_count==0</code>)且不需要同步操作的缓冲块最优先；</li>
<li>引用计数为零且正在同步的(<code>b_lock==1</code>)缓冲块次之；</li>
<li>引用计数为零且需要同步(<code>b_dirt==0</code>)但还没有开始同步的(<code>b_lock==0</code>)块再次；</li>
<li>如果没有引用计数为零的缓冲块，说明所有缓冲块都被其它进程占用了。内核会挂起当前进程，等待空闲缓冲块。</li>
</ol>
<h2 id="Part-IV-文件系统第一步：加载根文件系统"><a href="#Part-IV-文件系统第一步：加载根文件系统" class="headerlink" title="Part IV 文件系统第一步：加载根文件系统"></a>Part IV 文件系统第一步：加载根文件系统</h2><h3 id="61-在代码中多次出现一个宏-ROOT-DEV，即根设备。什么是根设备？与文件系统、根文件系统有什么关系？"><a href="#61-在代码中多次出现一个宏-ROOT-DEV，即根设备。什么是根设备？与文件系统、根文件系统有什么关系？" class="headerlink" title="61. 在代码中多次出现一个宏 ROOT_DEV，即根设备。什么是根设备？与文件系统、根文件系统有什么关系？"></a>61. 在代码中多次出现一个宏 <code>ROOT_DEV</code>，即根设备。什么是根设备？与文件系统、根文件系统有什么关系？</h3><p>操作系统中的文件系统大致可以分为两部分：一部分在操作系统内核中，另一部分在硬盘、软盘、虚拟盘中。每个逻辑盘（例如硬盘的分区、虚拟盘）中由索引节点（i节点，inode）和目录文件形成文件的树状结构，构成了每个逻辑盘中的文件系统。每个逻辑盘中的文件系统有一个根索引节点，由根索引节点便可找到文件系统中的所有文件。</p>
<p>硬盘可以有多个分区，每个分区中有自己单独的文件系统，因此操作系统可能要面对多个文件系统。然而 Unix 和 Linux 系统中最终呈现给用户的是一个单独的文件树，所有的设备、文件都被组织到了一棵单独的树上。这一矛盾是怎么解决的呢？<strong>为此，不同的文件系统需要相互挂载，</strong>一个文件系统的根索引节点会被挂载到另一文件系统的某个目录上。这样一来，被挂载的文件系统就好像是上层文件系统的一个目录一样。在 Linux 系统中，可以通过大家熟悉的 <code>mount</code> 指令实现文件系统之间的挂载。</p>
<p><strong>当文件系统相互挂载，最上层的文件系统便被称为根文件系统。</strong>根文件系统的根节点成为了整个 Linux 文件树的根，而其它文件系统只是 Linux 文件树中的一个目录。<strong>进一步的，根文件系统所在的设备就叫根设备。</strong></p>
<h3 id="62-在虚拟盘被设置为根设备之前，操作系统的根设备是软盘，请说明设置软盘为根设备的技术路线。"><a href="#62-在虚拟盘被设置为根设备之前，操作系统的根设备是软盘，请说明设置软盘为根设备的技术路线。" class="headerlink" title="62. 在虚拟盘被设置为根设备之前，操作系统的根设备是软盘，请说明设置软盘为根设备的技术路线。"></a>62. <strong>在虚拟盘被设置为根设备之前，操作系统的根设备是软盘，请说明设置软盘为根设备的技术路线。</strong></h3><p>首先，将软盘的第一个扇区设置为可引导扇区:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 代码路径：boot&#x2F;bootsect.s</span><br><span class="line">.org 508</span><br><span class="line">root_dev:</span><br><span class="line">        .word ROOT_DEV</span><br><span class="line">boot_flag:</span><br><span class="line">        .word 0xAA55</span><br></pre></td></tr></table></figure>
<p>在主 <code>Makefile</code> 文件中设置 <code>ROOT_DEV=/dev/hd6</code>。并且在 <code>bootsect.s</code> 中的第 508 和 509 比特处设置<code>ROOT_DEV=0x306</code>；在 <code>tools/build</code> 中根据 <code>Makefile</code> 中的 <code>ROOT_DEV</code> 设置 <code>MAJOR_TOOT</code> 和 <code>MINOR_ROOT</code>，并将其填充在偏移量为 508 和 509 处：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 代码路径：Makefile</span></span><br><span class="line">Image: boot/bootsect boot/setup tools/system tools/build</span><br><span class="line">        tools/build boot/bootsect boot/setup tools/system $(ROOT_DEV) &gt; Image</span><br><span class="line">        sync</span><br></pre></td></tr></table></figure>
<p>随后被移至 <code>0x90000+508=0x901FC</code> 处，最终在 <code>main.c</code> 中设置为 <code>ORIG_ROOT_DEV</code> 并将其赋给 <code>ROOT_DEV</code> 变量：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 代码路径：init/main.c</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ORIG_ROOT_DEV (*(unsigned short *)0x901FC)</span></span><br><span class="line">ROOT_DEV = ORIG_ROOT_DEV;</span><br></pre></td></tr></table></figure>
<h3 id="63-Linux-0-11-是怎么将根设备从软盘更换为虚拟盘，并加载了根文件系统？"><a href="#63-Linux-0-11-是怎么将根设备从软盘更换为虚拟盘，并加载了根文件系统？" class="headerlink" title="63. Linux-0.11 是怎么将根设备从软盘更换为虚拟盘，并加载了根文件系统？"></a>63. Linux-0.11 是怎么将根设备从软盘更换为虚拟盘，并加载了根文件系统？</h3><p>操作系统自启动之后就在不断地挪移、覆盖 <code>ROOT_DEV</code> 变量的值，直到 <code>mount_root</code> 函数中才真正地根据该变量的值挂载根文件系统。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 代码路径：kernel/blk_drv/hd.c</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sys_setup</span><span class="params">(<span class="keyword">void</span> * BIOS)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        ......</span><br><span class="line">        rd_load(); <span class="comment">// 格式化虚拟盘，覆盖ROOT_DEV变量为虚拟盘的设备号</span></span><br><span class="line">        mount_root(); <span class="comment">// 真正挂载根文件系统</span></span><br><span class="line">        <span class="keyword">return</span> (<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>rd_load</code> 函数<strong>首先</strong>从软盘读取虚拟盘的文件系统映像 (image) 并将其复制到虚拟盘中，<strong>随后</strong>设置 <code>ROOT_DEV</code> 为 <code>0x0101</code> 将根设备从软盘更换为虚拟盘。主设备号是1，代表内存，即将内存虚拟盘设置为根目录。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 代码路径：kernel/blk_drv/ramdisk.c</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rd_load</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        ......</span><br><span class="line">        ROOT_DEV=<span class="number">0x0101</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>随后，<code>sys_setup</code> 调用 <code>mount_root</code> 函数，真正地挂载根文件系统。过程如下：<strong>首先</strong>，初始化文件管理结构 <code>file_table[64]</code> 和超级块数据结构 <code>super_block[8]</code>。<strong>随后</strong>，读取根文件系统的超级块和根索引节点。<strong>然后</strong>，将超级块和根索引节点关联起来，并将根文件系统的根索引节点设置为1进程的当前工作目录和根目录。最后，统计空闲逻辑块数及空闲索引节点数，并打印显示给用户。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 代码路径：fs/super.c</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mount_root</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        ......</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">super_block</span> * <span class="title">p</span>;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">m_inode</span> * <span class="title">mi</span>;</span></span><br><span class="line">		......</span><br><span class="line">        <span class="comment">// 初始化文件管理结构file_table[64]</span></span><br><span class="line">        <span class="comment">// 初始化内存中的超级块数组super_block[8]</span></span><br><span class="line">        ......</span><br><span class="line">        <span class="keyword">if</span> (!(p=read_super(ROOT_DEV))) <span class="comment">// 从根设备上读取超级块</span></span><br><span class="line">                panic(<span class="string">&quot;Unable to mount root&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (!(mi=iget(ROOT_DEV,ROOT_INO))) <span class="comment">// 读取根设备上的根索引节点</span></span><br><span class="line">                panic(<span class="string">&quot;Unable to read root i-node&quot;</span>);</span><br><span class="line">        <span class="comment">// 增加i节点的引用计数</span></span><br><span class="line">        mi-&gt;i_count += <span class="number">3</span> ;	<span class="comment">/* NOTE! it is logically used 4 times, not 1 */</span></span><br><span class="line">        <span class="comment">// 将超级块关联到根索引节点上</span></span><br><span class="line">        p-&gt;s_isup = p-&gt;s_imount = mi;</span><br><span class="line">        <span class="comment">// 将根文件系统的根索引节点设置为当前进程的当前工作目录和根目录——此时当前进程是1进程。</span></span><br><span class="line">        current-&gt;pwd = mi;</span><br><span class="line">        current-&gt;root = mi;</span><br><span class="line">        ......</span><br><span class="line">        <span class="comment">// 统计根文件系统中的空闲逻辑块数量、逻辑块总数、空闲i节点数量、i节点总数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p>[1] Linux kernel source code, by Linus Torvalds et al., version 0.11(0.95), 1991.</p>
<p>[2] 《Linux内核设计的艺术》，新设计团队（即杨力祥老师带领的团队^_^） 著，第2版，2013年出版.</p>
<p>[3] 《Linux内核完全注释 内核版本0.11(0.95)》，赵炯 著，修正版1.9.5，2004年.</p>
<p>[4] <em>IA-32 Intel® Architecture Software Developer’s Manual</em>, by Intel, 2003.</p>
<p>[5] 《IA-32 架构软件开发人员手册 第3卷：系统编程指南（中文版-部分）》，lijshu等 译，2005年.</p>
<p>[6] 为什么BIOS要将主引导扇区（MBR）加载到0x7c00这个地址？，by greatgeek，CSDN，<a target="_blank" rel="noopener" href="https://blog.csdn.net/greatgeek/article/details/102542271">https://blog.csdn.net/greatgeek/article/details/102542271</a>，2019年.</p>
<p>[7] 知乎问题“在游戏的发展历史中，出现过哪些有意思的加密反盗版机制和破解机制？”下用户「Zign」的回答，by Zign，知乎，<a target="_blank" rel="noopener" href="https://www.zhihu.com/question/46773069">https://www.zhihu.com/question/46773069</a>，2018年.</p>
<p>[8] OldLinux（赵炯博士创建的在线Linux分享讨论平台），<a target="_blank" rel="noopener" href="http://www.oldlinux.org">www.oldlinux.org</a>.</p>
<h2 id="附录：思考题调整前后编号对照表"><a href="#附录：思考题调整前后编号对照表" class="headerlink" title="附录：思考题调整前后编号对照表"></a>附录：思考题调整前后编号对照表</h2><p>在修订时，为了让问题之间的逻辑更加连贯，我重新调整了思考题的顺序。为了方便与原版思考题题目对照参考、查找答案，我把原编号和现编号的对照关系放在这里。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>现 → 原</th>
<th>1 → 1</th>
<th>2 → 2</th>
<th>3 → 3</th>
</tr>
</thead>
<tbody>
<tr>
<td>4 → 4</td>
<td>5 → 5</td>
<td>6 → 6</td>
<td>7 → 41</td>
</tr>
<tr>
<td>8 → 7</td>
<td>9 → 44</td>
<td>10 → 40</td>
<td>11 → 8</td>
</tr>
<tr>
<td>12 → 9</td>
<td>13 → 10</td>
<td>14 → 11</td>
<td>15 → 42</td>
</tr>
<tr>
<td>16 → 12</td>
<td>17 → 61</td>
<td>18 → 43</td>
<td>19 → 13</td>
</tr>
<tr>
<td>20 → 14</td>
<td>21 → 62</td>
<td>22 → 15</td>
<td>23 → 17</td>
</tr>
<tr>
<td>24 → 16</td>
<td>25 → 46</td>
<td>26 → 53</td>
<td>27 → 18</td>
</tr>
<tr>
<td>28 → 47</td>
<td>29 → 48</td>
<td>30 → 19</td>
<td>31 → 49</td>
</tr>
<tr>
<td>32 → 56</td>
<td>33 → 20</td>
<td>34 → 21</td>
<td>35 → 50</td>
</tr>
<tr>
<td>36 → 22</td>
<td>37 → 23</td>
<td>38 → 45</td>
<td>39 → 24</td>
</tr>
<tr>
<td>40 → 29</td>
<td>41 → 51</td>
<td>42 → 52</td>
<td>43 → 25</td>
</tr>
<tr>
<td>44 → 54</td>
<td>45 → 26</td>
<td>46 → 27</td>
<td>47 → 28</td>
</tr>
<tr>
<td>48 → 30</td>
<td>49 → 31</td>
<td>50 → 32</td>
<td>51 → 33</td>
</tr>
<tr>
<td>52 → 34</td>
<td>53 → 35</td>
<td>54 → 36</td>
<td>55 → 37</td>
</tr>
<tr>
<td>56 → 38</td>
<td>57 → 63</td>
<td>58 → 60</td>
<td>59 → 55</td>
</tr>
<tr>
<td>60 → 57</td>
<td>61 → 原创</td>
<td>62 → 58</td>
<td>63 → 59</td>
</tr>
</tbody>
</table>
</div>
</div><div class="article-licensing box"><div class="licensing-title"><p>Linux-0.11 源码解析与思考题</p><p><a href="http://icychlorine.github.io/2022/12/31/Linux-0-11-源码解析与思考题/">http://icychlorine.github.io/2022/12/31/Linux-0-11-源码解析与思考题/</a></p></div><div class="licensing-meta level is-mobile"><div class="level-left"><div class="level-item is-narrow"><div><h6>作者</h6><p>IcyChlorine</p></div></div><div class="level-item is-narrow"><div><h6>发布于</h6><p>2022-12-31</p></div></div><div class="level-item is-narrow"><div><h6>更新于</h6><p>2022-12-31</p></div></div><div class="level-item is-narrow"><div><h6>许可协议</h6><p><a class="icon" rel="noopener" target="_blank" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a><a class="icon" rel="noopener" target="_blank" title="Attribution" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a><a class="icon" rel="noopener" target="_blank" title="Noncommercial" href="https://creativecommons.org/licenses/by-nc/4.0/"><i class="fab fa-creative-commons-nc"></i></a><a class="icon" rel="noopener" target="_blank" title="ShareAlike" href="https://creativecommons.org/licenses/by-nc-sa/4.0/"><i class="fab fa-creative-commons-sa"></i></a></p></div></div></div></div></div><div class="article-tags is-size-7 mb-4"><span class="mr-2">#</span><a class="link-muted mr-2" rel="tag" href="/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">操作系统</a><a class="link-muted mr-2" rel="tag" href="/tags/Linux/">Linux</a></div><div class="sharethis-inline-share-buttons"></div><script src="https://platform-api.sharethis.com/js/sharethis.js#property=5fb48effefe98e0012650837&amp;product=inline-share-buttons" defer></script></article></div><!--!--><nav class="post-navigation mt-4 level is-mobile"><div class="level-start"><a class="article-nav-prev level level-item link-muted" href="/2023/06/16/%E7%94%A8%E7%BA%BF%E6%80%A7%E8%A7%84%E5%88%92%E8%A7%A3%E5%86%B3%E3%80%8A%E6%88%B4%E6%A3%AE%E7%90%83%E8%AE%A1%E5%88%92%E3%80%8B%E4%B8%AD%E7%9A%84%E7%94%9F%E4%BA%A7%E8%A7%84%E5%88%92%E9%97%AE%E9%A2%98/"><i class="level-item fas fa-chevron-left"></i><span class="level-item">用线性规划解决《戴森球计划》中的生产规划问题</span></a></div><div class="level-end"><a class="article-nav-next level level-item link-muted" href="/2022/12/19/Notes-A-Link-Layer-Protocol-for-Quantum-Networks/"><span class="level-item">Notes: A Link Layer Protocol for Quantum Networks</span><i class="level-item fas fa-chevron-right"></i></a></div></nav><div class="card"><div class="card-content"><h3 class="title is-5">评论</h3><div class="notification is-danger">You forgot to set the <code>shortname</code> for Disqus. Please set it in <code>_config.yml</code>.</div></div></div></div><div class="column column-left is-4-tablet is-4-desktop is-4-widescreen  order-1"><div class="card widget" data-type="profile"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="avatar is-rounded" src="/img/avatar.webp" alt="李辰剑"></figure><p class="title is-size-4 is-block" style="line-height:inherit;">李辰剑</p><p class="is-size-6 is-block">IcyChlorine</p><p class="is-size-6 is-flex justify-content-center"><i class="fas fa-map-marker-alt mr-1"></i><span>Beijing/Shanghai, China</span></p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">文章</p><a href="/archives"><p class="title">12</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">分类</p><a href="/categories"><p class="title">0</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">标签</p><a href="/tags"><p class="title">16</p></a></div></div></nav><div class="level"><a class="level-item button is-primary is-rounded" href="https://github.com/IcyChlorine" target="_blank" rel="noopener">关注我</a></div><div class="level is-mobile is-multiline"><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Github" href="https://github.com/IcyChlorine"><i class="fab fa-github"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Bilibili" href="https://space.bilibili.com/35731772"><i class="fas fa-cannabis"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Zhihu" href="https://www.zhihu.com/people/li-chen-jian-29"><i class="fab fa-zhihu"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Netease-Cloud-Music" href="https://music.163.com/#/user/home?id=306748708"><i class="fab fa-itunes-note"></i></a></div></div></div><!--!--><div class="card widget" data-type="links"><div class="card-content"><div class="menu"><h3 class="menu-label">链接</h3><ul class="menu-list"><li><a class="level is-mobile" href="https://hexo.io" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">Hexo</span></span><span class="level-right"><span class="level-item tag">hexo.io</span></span></a></li><li><a class="level is-mobile" href="https://space.bilibili.com/35731772" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">Bilibili</span></span><span class="level-right"><span class="level-item tag">space.bilibili.com</span></span></a></li><li><a class="level is-mobile" href="https://spiritedawaycn.github.io" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">SpiritedAwayCN&#039;s blog</span></span><span class="level-right"><span class="level-item tag">spiritedawaycn.github.io</span></span></a></li><li><a class="level is-mobile" href="https://florestan-eusebius.github.io/about.html" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">逸飞姐姐的博客</span></span><span class="level-right"><span class="level-item tag">florestan-eusebius.github.io</span></span></a></li></ul></div></div></div><!--!--><div class="card widget" data-type="recent-posts"><div class="card-content"><h3 class="menu-label">最新文章</h3><article class="media"><div class="media-content"><p class="date"><time dateTime="2024-07-27T15:04:03.000Z">2024-07-27</time></p><p class="title"><a href="/2024/07/27/%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6%E4%B8%AD%E7%9A%84%E6%81%92%E7%AD%89%E5%BC%8F/">组合数学中的恒等式</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2024-03-25T08:06:20.000Z">2024-03-25</time></p><p class="title"><a href="/2024/03/25/%E4%BB%8E%E7%94%B5%E5%AD%90%E5%8F%8C%E7%BC%9D%E5%B9%B2%E6%B6%89%E5%88%B0%E8%B6%85%E5%AF%BC%E5%B9%B2%E6%B6%89(SQUID)/">从电子双缝干涉到超导干涉(SQUID)</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2023-06-16T13:48:29.000Z">2023-06-16</time></p><p class="title"><a href="/2023/06/16/%E7%94%A8%E7%BA%BF%E6%80%A7%E8%A7%84%E5%88%92%E8%A7%A3%E5%86%B3%E3%80%8A%E6%88%B4%E6%A3%AE%E7%90%83%E8%AE%A1%E5%88%92%E3%80%8B%E4%B8%AD%E7%9A%84%E7%94%9F%E4%BA%A7%E8%A7%84%E5%88%92%E9%97%AE%E9%A2%98/">用线性规划解决《戴森球计划》中的生产规划问题</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2022-12-31T12:16:00.000Z">2022-12-31</time></p><p class="title"><a href="/2022/12/31/Linux-0-11-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%E4%B8%8E%E6%80%9D%E8%80%83%E9%A2%98/">Linux-0.11 源码解析与思考题</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2022-12-19T01:05:22.000Z">2022-12-19</time></p><p class="title"><a href="/2022/12/19/Notes-A-Link-Layer-Protocol-for-Quantum-Networks/">Notes: A Link Layer Protocol for Quantum Networks</a></p></div></article></div></div><div class="card widget" data-type="archives"><div class="card-content"><div class="menu"><h3 class="menu-label">归档</h3><ul class="menu-list"><li><a class="level is-mobile" href="/archives/2024/07/"><span class="level-start"><span class="level-item">七月 2024</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2024/03/"><span class="level-start"><span class="level-item">三月 2024</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2023/06/"><span class="level-start"><span class="level-item">六月 2023</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2022/12/"><span class="level-start"><span class="level-item">十二月 2022</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/archives/2022/06/"><span class="level-start"><span class="level-item">六月 2022</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2022/01/"><span class="level-start"><span class="level-item">一月 2022</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2021/09/"><span class="level-start"><span class="level-item">九月 2021</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2021/06/"><span class="level-start"><span class="level-item">六月 2021</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2021/04/"><span class="level-start"><span class="level-item">四月 2021</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li></ul></div></div></div><div class="card widget" data-type="tags"><div class="card-content"><div class="menu"><h3 class="menu-label">标签</h3><div class="field is-grouped is-grouped-multiline"><div class="control"><a class="tags has-addons" href="/tags/Linux/"><span class="tag">Linux</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%8E%9F%E5%AD%90%E6%A0%B8/"><span class="tag">原子核</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%BB%BA%E6%A8%A1/"><span class="tag">建模</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"><span class="tag">操作系统</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%95%B0%E5%AD%A6/"><span class="tag">数学</span><span class="tag">5</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%B8%B8%E6%88%8F/"><span class="tag">游戏</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E7%94%B5%E5%AD%90/"><span class="tag">电子</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E7%A7%AF%E5%88%86/"><span class="tag">积分</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E7%AD%89%E6%AF%94%E6%95%B0%E5%88%97/"><span class="tag">等比数列</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E7%BA%A6%E6%9D%9F%E6%B1%82%E8%A7%A3/"><span class="tag">约束求解</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6/"><span class="tag">组合数学</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E8%A7%86%E9%A2%91/"><span class="tag">视频</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0/"><span class="tag">论文笔记</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E9%87%8F%E5%AD%90%E5%8A%9B%E5%AD%A6/"><span class="tag">量子力学</span><span class="tag">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E9%87%8F%E5%AD%90%E8%AE%A1%E7%AE%97/"><span class="tag">量子计算</span><span class="tag">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E9%87%8F%E5%AD%90%E9%80%9A%E4%BF%A1/"><span class="tag">量子通信</span><span class="tag">1</span></a></div></div></div></div></div></div><!--!--></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="/img/avatar.webp" alt="IcyChlorine&#039;s Blog" height="28"></a><p class="is-size-7"><span>&copy; 2024 IcyChlorine</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a><br><span id="busuanzi_container_site_uv">共<span id="busuanzi_value_site_uv">0</span>个访客</span></p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Attribution 4.0 International" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/ppoffice/hexo-theme-icarus"><i class="fab fa-github"></i></a></p></div></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script><script>moment.locale("zh-CN");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="/js/column.js"></script><script src="/js/animation.js"></script><a id="back-to-top" title="回到顶端" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><!--!--><!--!--><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.js" defer></script><script>window.addEventListener("load", () => {
      window.cookieconsent.initialise({
        type: "info",
        theme: "edgeless",
        static: false,
        position: "bottom-left",
        content: {
          message: "此网站使用Cookie来改善您的体验。",
          dismiss: "知道了！",
          allow: "允许使用Cookie",
          deny: "拒绝",
          link: "了解更多",
          policy: "Cookie政策",
          href: "https://www.cookiesandyou.com/",
        },
        palette: {
          popup: {
            background: "#edeff5",
            text: "#838391"
          },
          button: {
            background: "#4b81e8"
          },
        },
      });
    });</script><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/katex.min.css"><script src="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/katex.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/contrib/auto-render.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/contrib/mhchem.js" defer></script><script>window.addEventListener("load", function() {
            document.querySelectorAll('[role="article"] > .content').forEach(function(element) {
                renderMathInElement(element);
            });
        });</script><script type="text/x-mathjax-config">MathJax.Hub.Config({
            'HTML-CSS': {
                matchFontHeight: false
            },
            SVG: {
                matchFontHeight: false
            },
            CommonHTML: {
                matchFontHeight: false
            },
            tex2jax: {
                inlineMath: [
                    ['$','$'],
                    ['\\(','\\)']
                ]
            }
        });</script><script src="https://cdn.jsdelivr.net/npm/mathjax@2.7.5/unpacked/MathJax.js?config=TeX-MML-AM_CHTML" defer></script><!--!--><!--!--><!--!--><script src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="想要查找什么..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"想要查找什么...","untitled":"(无标题)","posts":"文章","pages":"页面","categories":"分类","tags":"标签"});
        });</script></body></html>